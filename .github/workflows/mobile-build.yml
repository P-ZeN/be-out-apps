name: Mobile App Build and Release

on:
  push:
    branches: [ mobile-build ]  # Only run on mobile-build branch
    paths:  # Only run when these files change
      - 'client/**'
      - '.github/workflows/mobile-build.yml'
      - 'package.json'
      - 'package-lock.json'
  pull_request:
    branches: [ mobile-build ]  # Only run PR checks when targeting mobile-build branch
    paths:  # Only run when these files change
      - 'client/**'
      - '.github/workflows/mobile-build.yml'
      - 'package.json'
      - 'package-lock.json'
  workflow_dispatch:  # Allow manual triggering from GitHub UI

env:
  CARGO_TERM_COLOR: always

jobs:
  test-client:
    name: Test Client App
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    - name: Install dependencies
      run: npm ci
    - name: Build client
      run: npm run build:client
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}
    - name: Test client
      run: npm run test --workspace=client --if-present

  build-android:
    name: Build Android APK
    runs-on: ubuntu-latest
    needs: test-client
    if: true  # Enabled
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Setup Java JDK
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-linux-android,armv7-linux-androideabi,x86_64-linux-android,i686-linux-android

    - name: Install Rust targets for Android
      run: |
        echo "Installing Android targets..."
        rustup target add aarch64-linux-android
        rustup target add armv7-linux-androideabi
        rustup target add x86_64-linux-android
        rustup target add i686-linux-android
        echo "Installed targets:"
        rustup target list --installed | grep android

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3
      with:
        api-level: 33
        build-tools: 33.0.0
        ndk-version: 25.2.9519653

    - name: Verify Android Environment
      run: |
        echo "Android SDK Root: $ANDROID_SDK_ROOT"
        echo "NDK Home: $ANDROID_SDK_ROOT/ndk/25.2.9519653"
        echo "Java Home: $JAVA_HOME"
        ls -la $ANDROID_SDK_ROOT/ndk/ || echo "NDK directory not found"
        # Find actual NDK directory
        if [ -d "$ANDROID_SDK_ROOT/ndk" ]; then
          echo "Available NDK versions:"
          ls -la $ANDROID_SDK_ROOT/ndk/
          NDK_DIR=$(ls -1 $ANDROID_SDK_ROOT/ndk/ | head -1)
          echo "Using NDK: $NDK_DIR"
          echo "NDK_HOME=$ANDROID_SDK_ROOT/ndk/$NDK_DIR" >> $GITHUB_ENV
        fi

    - name: Configure Cargo for Android
      run: |
        echo "Setting up Cargo configuration for Android builds..."
        echo "Using NDK_HOME: $NDK_HOME"
        mkdir -p ~/.cargo

        # Verify NDK tools exist before creating config
        NDK_TOOLCHAIN="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin"
        echo "Checking NDK toolchain at: $NDK_TOOLCHAIN"

        if [ ! -d "$NDK_TOOLCHAIN" ]; then
          echo "âŒ NDK toolchain directory not found: $NDK_TOOLCHAIN"
          echo "Available NDK contents:"
          find "$NDK_HOME" -type d -name "bin" 2>/dev/null | head -5
          exit 1
        fi

        # Find the correct Android API level linkers
        echo "Looking for Android clang linkers..."
        AARCH64_LINKER=$(find "$NDK_TOOLCHAIN" -name "*aarch64*android*clang" | head -1)
        ARMV7_LINKER=$(find "$NDK_TOOLCHAIN" -name "*armv7*android*clang" -o -name "*arm*android*clang" | head -1)
        X86_64_LINKER=$(find "$NDK_TOOLCHAIN" -name "*x86_64*android*clang" | head -1)
        I686_LINKER=$(find "$NDK_TOOLCHAIN" -name "*i686*android*clang" | head -1)

        echo "Found linkers:"
        echo "AARCH64: $AARCH64_LINKER"
        echo "ARMV7: $ARMV7_LINKER"
        echo "X86_64: $X86_64_LINKER"
        echo "I686: $I686_LINKER"

        # Use found linkers or fallback to API level 21
        AARCH64_LINKER=${AARCH64_LINKER:-"$NDK_TOOLCHAIN/aarch64-linux-android21-clang"}
        ARMV7_LINKER=${ARMV7_LINKER:-"$NDK_TOOLCHAIN/armv7a-linux-androideabi21-clang"}
        X86_64_LINKER=${X86_64_LINKER:-"$NDK_TOOLCHAIN/x86_64-linux-android21-clang"}
        I686_LINKER=${I686_LINKER:-"$NDK_TOOLCHAIN/i686-linux-android21-clang"}

        # Create Cargo config with discovered linkers
        cat > ~/.cargo/config.toml << 'CARGO_EOF'
        [target.aarch64-linux-android]
        ar = "AR_PLACEHOLDER"
        linker = "AARCH64_LINKER_PLACEHOLDER"

        [target.armv7-linux-androideabi]
        ar = "AR_PLACEHOLDER"
        linker = "ARMV7_LINKER_PLACEHOLDER"

        [target.x86_64-linux-android]
        ar = "AR_PLACEHOLDER"
        linker = "X86_64_LINKER_PLACEHOLDER"

        [target.i686-linux-android]
        ar = "AR_PLACEHOLDER"
        linker = "I686_LINKER_PLACEHOLDER"
        CARGO_EOF

        # Replace placeholders with actual paths
        sed -i "s|AR_PLACEHOLDER|$NDK_TOOLCHAIN/llvm-ar|g" ~/.cargo/config.toml
        sed -i "s|AARCH64_LINKER_PLACEHOLDER|$AARCH64_LINKER|g" ~/.cargo/config.toml
        sed -i "s|ARMV7_LINKER_PLACEHOLDER|$ARMV7_LINKER|g" ~/.cargo/config.toml
        sed -i "s|X86_64_LINKER_PLACEHOLDER|$X86_64_LINKER|g" ~/.cargo/config.toml
        sed -i "s|I686_LINKER_PLACEHOLDER|$I686_LINKER|g" ~/.cargo/config.toml

        echo "Cargo config created:"
        cat ~/.cargo/config.toml

        # Verify all tools exist
        echo "Verifying all tools exist:"
        for tool in "$NDK_TOOLCHAIN/llvm-ar" "$AARCH64_LINKER" "$ARMV7_LINKER" "$X86_64_LINKER" "$I686_LINKER"; do
          if [ -f "$tool" ]; then
            echo "âœ… $tool"
          else
            echo "âŒ $tool (not found)"
          fi
        done
      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Verify NDK Tools
      run: |
        echo "Verifying NDK tools are available..."
        echo "NDK_HOME: $NDK_HOME"
        ls -la "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" | head -10

        # Test if the linkers exist
        if [ -f "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang" ]; then
          echo "âœ… ARM64 linker found"
        else
          echo "âŒ ARM64 linker not found"
          echo "Available linkers:"
          find "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" -name "*android*clang*" | head -5
        fi
      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Install Tauri CLI
      run: |
        echo "Installing Tauri CLI (latest version)..."
        npm install -g @tauri-apps/cli@latest

        echo "Verifying Tauri CLI installation..."
        which tauri || echo "Tauri CLI not found in PATH"
        tauri --version || echo "Failed to get Tauri version"

        echo "Checking if tauri is available via npx..."
        npx tauri --version || echo "npx tauri failed"

        echo "Installing Tauri CLI locally as well..."
        npm install @tauri-apps/cli@latest

        echo "Verifying local installation..."
        npx tauri --version || echo "Local npx tauri failed"

        echo "Checking package.json scripts..."
        cat package.json | grep -A 5 -B 5 "scripts" || echo "No scripts section found"

    - name: Install dependencies
      run: npm ci

    - name: Setup Android Code Signing
      working-directory: ./client
      run: |
        echo "Setting up Android code signing for CI..."

        # Create keystore directory
        mkdir -p android/

        # Decode and save the keystore file with CI environment variables approach
        if [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ]; then
          echo "âœ… Android keystore found in secrets"
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > android/release.keystore

          echo "âœ… Android code signing configured with environment variables"
          ls -la android/release.keystore
        else
          echo "âš ï¸  No Android keystore found in secrets - building unsigned APK"
          echo "To enable signed builds, add these secrets to your GitHub repository:"
          echo "- ANDROID_KEYSTORE_BASE64: Base64 encoded keystore file"
          echo "- ANDROID_KEYSTORE_PASSWORD: Keystore password"
          echo "- ANDROID_KEY_ALIAS: Key alias"
          echo "- ANDROID_KEY_PASSWORD: Key password"
        fi

    - name: Debug Signing Setup
      working-directory: ./client
      run: |
        echo "=== Checking CI signing setup ==="
        if [ -f "android/release.keystore" ]; then
          echo "âœ… Keystore file exists at android/release.keystore"
          ls -la android/release.keystore
        else
          echo "âŒ Keystore file not found"
          ls -la android/ || echo "Android directory not found"
        fi

        echo "=== Environment variables for signing ==="
        echo "CI: $CI"
        echo "KEYSTORE_PATH: $KEYSTORE_PATH"
        echo "ANDROID_HOME: $ANDROID_HOME"
        echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"

        # Check if all required signing environment variables are set (without showing values)
        if [ -n "$KEYSTORE_PASSWORD" ]; then
          echo "âœ… KEYSTORE_PASSWORD is set"
        else
          echo "âŒ KEYSTORE_PASSWORD not set"
        fi

        if [ -n "$KEY_ALIAS" ]; then
          echo "âœ… KEY_ALIAS is set"
        else
          echo "âŒ KEY_ALIAS not set"
        fi

        if [ -n "$KEY_PASSWORD" ]; then
          echo "âœ… KEY_PASSWORD is set"
        else
          echo "âŒ KEY_PASSWORD not set"
        fi
      env:
        # Android signing environment variables for debugging
        CI: true
        KEYSTORE_PATH: android/release.keystore
        KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

    - name: Build client
      run: npm run build:client
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}

    - name: Generate App Icons
      working-directory: ./client
      run: |
        echo "Generating app icons for mobile platforms..."

        # Check if the icon file exists
        ICON_FILE="src-tauri/icons/be-out_icon_512x512.png"
        if [ -f "$ICON_FILE" ]; then
          echo "âœ… Found icon file: $ICON_FILE"
          ls -la "$ICON_FILE"

          echo "Generating icons using Tauri CLI..."
          if npx tauri icon "$ICON_FILE"; then
            echo "âœ… Icons generated successfully"

            # Show generated icons
            echo "=== Generated icons ==="
            find src-tauri/icons -name "*.png" -o -name "*.ico" | head -10
          else
            echo "âŒ Failed to generate icons"
            echo "Trying with local Tauri CLI..."
            cargo tauri icon "$ICON_FILE" || echo "Local cargo tauri also failed"
          fi
        else
          echo "âš ï¸  Icon file not found: $ICON_FILE"
          echo "Available files in src-tauri/icons/:"
          ls -la src-tauri/icons/ || echo "Icons directory not found"

          # Try to find any PNG files that could be used as icons
          echo "Looking for alternative icon files..."
          find src-tauri -name "*.png" | head -5
        fi

    - name: Initialize Android project
      working-directory: ./client
      run: |
        echo "Initializing Tauri Android project..."
        echo "Environment variables:"
        echo "ANDROID_HOME: $ANDROID_HOME"
        echo "NDK_HOME: $NDK_HOME"
        echo "JAVA_HOME: $JAVA_HOME"

        echo "Available npm scripts in client directory:"
        npm run | grep tauri || echo "No tauri scripts found"

        echo "Checking Tauri CLI availability:"
        npx tauri --version || echo "npx tauri not available"

        # Try different approaches to run tauri android init
        echo "Attempting to initialize Android project..."

        # Try npm scripts first, then npx
        if npm run tauri:android:init -- --ci; then
          echo "âœ… Android project initialized with npm script"
        elif npx tauri android init --ci; then
          echo "âœ… Android project initialized with npx tauri"
        else
          echo "âŒ All initialization methods failed"
          echo "Checking Tauri CLI installation..."

          # Debug information
          npm list @tauri-apps/cli || echo "Local @tauri-apps/cli not found"
          ls -la node_modules/.bin/ | grep tauri || echo "No tauri in node_modules/.bin"
          echo "Checking root node_modules:"
          ls -la ../node_modules/.bin/ | grep tauri || echo "No tauri in root node_modules/.bin"
        fi

        echo "Checking for generated project..."
        find . -name "gen" -type d 2>/dev/null || echo "No gen directory found"
        find . -name "android" -type d 2>/dev/null || echo "No android directory found"

        # Check if Android project was created
        if [ -d "src-tauri/gen/android" ]; then
          echo "âœ… Android project created successfully"
          ls -la src-tauri/gen/
        else
          echo "âŒ Android project directory not found, trying alternative paths..."
          find src-tauri -type d -name "*android*" 2>/dev/null || echo "No Android directories found"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}
        JAVA_HOME: ${{ env.JAVA_HOME }}

    - name: Debug Android Project Generation (Compare with Local)
      working-directory: ./client
      run: |
        echo "=== DEBUGGING: Android Project Generation for Local vs CI Comparison ==="

        if [ -d "src-tauri/gen/android" ]; then
          echo "ðŸ” Analyzing generated Android project..."

          echo "=== 1. Tauri CLI Version Info ==="
          npx tauri --version || echo "npx tauri version failed"
          cargo tauri --version || echo "cargo tauri version failed"

          echo "=== 2. Android Project Structure ==="
          find src-tauri/gen/android -type f -name "*.xml" -o -name "*.gradle*" -o -name "*.kt" | head -20

          echo "=== 3. Android Manifest Contents (COMPLETE) ==="
          if [ -f "src-tauri/gen/android/app/src/main/AndroidManifest.xml" ]; then
            echo "--- COMPLETE AndroidManifest.xml ---"
            cat src-tauri/gen/android/app/src/main/AndroidManifest.xml
            echo "--- END AndroidManifest.xml ---"
          else
            echo "âŒ AndroidManifest.xml not found"
            find src-tauri/gen/android -name "AndroidManifest.xml" 2>/dev/null || echo "No manifest files found"
          fi

          echo "=== 4. Android Themes (CRITICAL FOR STATUS BAR) ==="
          echo "--- themes.xml ---"
          cat src-tauri/gen/android/app/src/main/res/values/themes.xml 2>/dev/null || echo "No themes.xml found"
          echo "--- themes.xml (night) ---"
          cat src-tauri/gen/android/app/src/main/res/values-night/themes.xml 2>/dev/null || echo "No night themes.xml found"
          echo "--- colors.xml ---"
          cat src-tauri/gen/android/app/src/main/res/values/colors.xml 2>/dev/null || echo "No colors.xml found"
          echo "--- strings.xml ---"
          cat src-tauri/gen/android/app/src/main/res/values/strings.xml 2>/dev/null || echo "No strings.xml found"

          echo "=== 5. Build Configuration Files ==="
          if [ -f "src-tauri/gen/android/app/build.gradle.kts" ]; then
            echo "--- app/build.gradle.kts (first 50 lines) ---"
            head -50 src-tauri/gen/android/app/build.gradle.kts
          fi

          if [ -f "src-tauri/gen/android/build.gradle.kts" ]; then
            echo "--- root build.gradle.kts ---"
            cat src-tauri/gen/android/build.gradle.kts
          fi

          echo "=== 6. Generated App Configuration ==="
          find src-tauri/gen/android -name "*.properties" -exec echo "--- {} ---" \; -exec cat {} \; 2>/dev/null || echo "No properties files found"

          echo "=== 7. Android Resources ==="
          echo "Generated drawable resources:"
          find src-tauri/gen/android -path "*/res/drawable*" -name "*.png" -o -name "*.xml" | head -10 || echo "No drawable resources found"

          echo "Generated layout resources:"
          find src-tauri/gen/android -path "*/res/layout*" -name "*.xml" | head -5 || echo "No layout resources found"

          echo "=== 8. Tauri Configuration Used ==="
          echo "--- tauri.conf.json ---"
          cat src-tauri/tauri.conf.json | head -50

          echo "=== 9. Environment Variables During Generation ==="
          env | grep -E "(ANDROID|TAURI|JAVA|SDK)" | sort

        else
          echo "âŒ No Android project found - initialization may have failed"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Fix Android Themes for Status Bar
      working-directory: ./client
      run: |
        echo "ðŸ”§ Fixing Android themes to prevent status bar overlap..."

        # Ensure the generated Android project exists
        if [ -d "src-tauri/gen/android" ]; then
          # Fix the main themes.xml file
          if [ -f "src-tauri/gen/android/app/src/main/res/values/themes.xml" ]; then
            echo "ðŸ“ Patching main themes.xml..."
            cat > src-tauri/gen/android/app/src/main/res/values/themes.xml << 'EOF'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        EOF
          else
            echo "âŒ Main themes.xml not found, creating it..."
            mkdir -p src-tauri/gen/android/app/src/main/res/values
            cat > src-tauri/gen/android/app/src/main/res/values/themes.xml << 'EOF'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        EOF
          fi

          # Fix the night themes.xml file if it exists
          if [ -f "src-tauri/gen/android/app/src/main/res/values-night/themes.xml" ]; then
            echo "ðŸ“ Patching night themes.xml..."
            cat > src-tauri/gen/android/app/src/main/res/values-night/themes.xml << 'EOF'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        EOF
          else
            echo "ðŸŒ™ Night themes.xml not found, creating it..."
            mkdir -p src-tauri/gen/android/app/src/main/res/values-night
            cat > src-tauri/gen/android/app/src/main/res/values-night/themes.xml << 'EOF'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        EOF
          fi

          echo "âœ… Android themes patched successfully!"
          echo "ðŸ“‹ Verifying theme files after patching:"
          find src-tauri/gen/android -name "themes.xml" -exec echo "--- {} ---" \; -exec cat {} \;
        else
          echo "âŒ No Android project found to patch"
        fi

    - name: Patch Android Build for Signing
      working-directory: ./client
      run: |
        echo "=== Patching Android app build.gradle.kts for signing ==="

        APP_BUILD_FILE="src-tauri/gen/android/app/build.gradle.kts"

        if [ -f "$APP_BUILD_FILE" ]; then
          echo "âœ… Found app build file: $APP_BUILD_FILE"

          # Create a backup
          cp "$APP_BUILD_FILE" "$APP_BUILD_FILE.backup"

          # Check if signingConfigs already exists (to avoid double-patching)
          if grep -q "signingConfigs" "$APP_BUILD_FILE"; then
            echo "âš ï¸ signingConfigs already exists, skipping patch"
          else
            echo "ðŸ”§ Adding signing configuration to app build file..."

            # Create the signing configuration content using echo statements
            echo "" > signing_config_patch.txt
            echo "    signingConfigs {" >> signing_config_patch.txt
            echo "        if (System.getenv(\"CI\") == \"true\" && System.getenv(\"KEYSTORE_PATH\") != null) {" >> signing_config_patch.txt
            echo "            create(\"release\") {" >> signing_config_patch.txt
            echo "                storeFile = file(\"../../../../\${System.getenv(\"KEYSTORE_PATH\")}\")" >> signing_config_patch.txt
            echo "                storePassword = System.getenv(\"KEYSTORE_PASSWORD\")" >> signing_config_patch.txt
            echo "                keyAlias = System.getenv(\"KEY_ALIAS\")" >> signing_config_patch.txt
            echo "                keyPassword = System.getenv(\"KEY_PASSWORD\")" >> signing_config_patch.txt
            echo "            }" >> signing_config_patch.txt
            echo "        } else {" >> signing_config_patch.txt
            echo "            // Load keystore properties from git-ignored file for local development" >> signing_config_patch.txt
            echo "            val keystoreProperties = Properties().apply {" >> signing_config_patch.txt
            echo "                val propFile = file(\"../../../../../src-tauri/keystore.properties\")" >> signing_config_patch.txt
            echo "                if (propFile.exists()) {" >> signing_config_patch.txt
            echo "                    propFile.inputStream().use { load(it) }" >> signing_config_patch.txt
            echo "                }" >> signing_config_patch.txt
            echo "            }" >> signing_config_patch.txt
            echo "" >> signing_config_patch.txt
            echo "            if (keystoreProperties.containsKey(\"keyAlias\")) {" >> signing_config_patch.txt
            echo "                create(\"release\") {" >> signing_config_patch.txt
            echo "                    storeFile = file(\"../../../../../src-tauri/\${keystoreProperties[\"storeFile\"]}\")" >> signing_config_patch.txt
            echo "                    storePassword = keystoreProperties[\"storePassword\"] as String" >> signing_config_patch.txt
            echo "                    keyAlias = keystoreProperties[\"keyAlias\"] as String" >> signing_config_patch.txt
            echo "                    keyPassword = keystoreProperties[\"keyPassword\"] as String" >> signing_config_patch.txt
            echo "                }" >> signing_config_patch.txt
            echo "            }" >> signing_config_patch.txt
            echo "        }" >> signing_config_patch.txt
            echo "    }" >> signing_config_patch.txt

            # Insert the signing configuration after the defaultConfig block
            # Use a simpler approach with awk to avoid sed delimiter issues
            awk '
            /defaultConfig \{/ { in_config = 1 }
            in_config && /^\s*\}/ && !inserted {
                print $0
                while ((getline line < "signing_config_patch.txt") > 0) {
                    print line
                }
                close("signing_config_patch.txt")
                inserted = 1
                next
            }
            { print }
            ' "$APP_BUILD_FILE" > "$APP_BUILD_FILE.tmp" && mv "$APP_BUILD_FILE.tmp" "$APP_BUILD_FILE"

            # Add signingConfig to the release buildType using a different approach
            # First create a temporary patch file for the signing config line
            echo "            signingConfig = signingConfigs.findByName(\"release\")" > buildtype_patch.txt

            # Insert the signingConfig line before the closing brace of the release buildType
            awk '
            /getByName\("release"\) \{/ { in_release = 1 }
            in_release && /^\s*\}/ && !inserted {
                while ((getline line < "buildtype_patch.txt") > 0) {
                    print line
                }
                close("buildtype_patch.txt")
                print $0
                inserted = 1
                next
            }
            { print }
            ' "$APP_BUILD_FILE" > "$APP_BUILD_FILE.tmp" && mv "$APP_BUILD_FILE.tmp" "$APP_BUILD_FILE"

            # Clean up the temporary file
            rm buildtype_patch.txt

            # Add validation block at the end, before rust block
            echo "" >> "$APP_BUILD_FILE"
            echo "afterEvaluate {" >> "$APP_BUILD_FILE"
            echo "    if (System.getenv(\"CI\") == \"true\") {" >> "$APP_BUILD_FILE"
            echo "        val signingConfig = android.signingConfigs.findByName(\"release\")" >> "$APP_BUILD_FILE"
            echo "        // Fail the build if signingConfig is missing or any value is missing" >> "$APP_BUILD_FILE"
            echo "        if (signingConfig == null ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.storeFile == null ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.storePassword.isNullOrBlank() ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.keyAlias.isNullOrBlank() ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.keyPassword.isNullOrBlank()" >> "$APP_BUILD_FILE"
            echo "        ) {" >> "$APP_BUILD_FILE"
            echo "            throw org.gradle.api.GradleException(\"Signing config for release build is missing or incomplete. Please check your environment variables.\")" >> "$APP_BUILD_FILE"
            echo "        }" >> "$APP_BUILD_FILE"
            echo "    }" >> "$APP_BUILD_FILE"
            echo "}" >> "$APP_BUILD_FILE"

            echo "âœ… Successfully patched app build file for signing"

            # Show the changes
            echo "=== Patched build file content (first 100 lines) ==="
            head -100 "$APP_BUILD_FILE"

            # Clean up
            rm signing_config_patch.txt
          fi
        else
          echo "âŒ App build file not found: $APP_BUILD_FILE"
          echo "Available files in Android project:"
          find src-tauri/gen/android -name "*.gradle*" 2>/dev/null || echo "No gradle files found"
        fi

    - name: Debug Gradle Build Process Before Tauri
      working-directory: ./client
      run: |
        echo "=== Manual Gradle Build Debug ==="

        if [ -d "src-tauri/gen/android" ]; then
          cd src-tauri/gen/android

          echo "=== Gradle Project Structure ==="
          ls -la

          echo "=== Gradle Wrapper Permissions ==="
          ls -la gradlew
          chmod +x gradlew

          echo "=== Gradle Version ==="
          ./gradlew --version

          echo "=== Android Project Tasks ==="
          ./gradlew tasks --all | head -50

          echo "=== Checking Build File Contents ==="
          echo "--- app/build.gradle.kts (first 50 lines) ---"
          head -50 app/build.gradle.kts || echo "No app build file found"

          echo "=== Trying Basic Gradle Build ==="
          if ./gradlew build --info --stacktrace 2>&1 | tee manual_gradle_build.log; then
            echo "âœ… Manual Gradle build succeeded"
          else
            echo "âŒ Manual Gradle build failed"
            echo "=== Last 50 lines of Gradle build log ==="
            tail -50 manual_gradle_build.log

            echo "=== Looking for specific error patterns ==="
            grep -i "error\|exception\|failed\|could not" manual_gradle_build.log | tail -20

            echo "=== Checking for signing-related errors ==="
            grep -i "sign\|keystore\|alias\|password" manual_gradle_build.log | tail -10
          fi
        else
          echo "âŒ Android project directory not found"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}
        JAVA_HOME: ${{ env.JAVA_HOME }}
        # Android signing environment variables
        CI: true
        KEYSTORE_PATH: android/release.keystore
        KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

    - name: Debug Rust Build Environment
      run: |
        echo "=== Rust Build Environment Debug ==="
        echo "Rust version:"
        rustc --version
        echo "Cargo version:"
        cargo --version
        echo "Installed targets:"
        rustup target list --installed
        echo "Cargo config:"
        cat ~/.cargo/config.toml || echo "No Cargo config found"
        echo "NDK tools verification:"
        ls -la "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" | grep -E "(aarch64|armv7|x86_64|i686).*android.*clang" || echo "No Android clang tools found"
        echo "Environment variables:"
        env | grep -E "(ANDROID|NDK|JAVA|CARGO|RUST)" | sort
      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Test Rust Cross-Compilation
      run: |
        echo "=== Testing Rust Cross-Compilation for Android ==="
        echo "Testing if we can compile a simple Rust program for Android targets..."

        # Create a simple test Rust program
        mkdir -p /tmp/rust_test
        cd /tmp/rust_test

        # Create Cargo.toml
        cat > Cargo.toml << 'CARGO_TOML_EOF'
        [package]
        name = "test_android"
        version = "0.1.0"
        edition = "2021"

        [[bin]]
        name = "test_android"
        path = "src/main.rs"
        CARGO_TOML_EOF

        # Create main.rs
        mkdir -p src
        cat > src/main.rs << 'MAIN_RS_EOF'
        fn main() {
            println!("Hello Android!");
        }
        MAIN_RS_EOF

        echo "Created test project, testing compilation for each Android target:"

        # Test aarch64-linux-android
        echo "Testing aarch64-linux-android..."
        if cargo build --target aarch64-linux-android --verbose 2>&1; then
          echo "âœ… aarch64-linux-android compilation successful"
        else
          echo "âŒ Failed to compile for aarch64-linux-android"
          echo "Checking linker configuration..."
          cat ~/.cargo/config.toml | grep -A 2 aarch64-linux-android || echo "No config found"
        fi

        # Test armv7-linux-androideabi
        echo "Testing armv7-linux-androideabi..."
        if cargo build --target armv7-linux-androideabi --verbose 2>&1; then
          echo "âœ… armv7-linux-androideabi compilation successful"
        else
          echo "âŒ Failed to compile for armv7-linux-androideabi"
          echo "Checking linker configuration..."
          cat ~/.cargo/config.toml | grep -A 2 armv7-linux-androideabi || echo "No config found"
        fi

      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Debug Gradle Build Process
      working-directory: ./client
      run: |
        echo "=== Debugging Gradle Build Process ==="
        cd src-tauri/gen/android

        echo "Gradle wrapper version:"
        ./gradlew --version

        echo "Android project tasks:"
        ./gradlew tasks --all | grep -E "(rust|Build)" || echo "No rust-related tasks found"

        echo "Attempting to run rustBuildArm64Release task manually with more details:"
        if ./gradlew :app:rustBuildArm64Release --info --stacktrace 2>&1 | tee gradle_rust_debug.log; then
          echo "âœ… Manual Gradle task succeeded"
        else
          echo "âŒ Manual Gradle task failed"
          echo "=== Gradle Error Analysis ==="
          tail -50 gradle_rust_debug.log
          echo "=== Looking for Node.js errors ==="
          grep -i "node\|javascript\|process.*finished.*non-zero" gradle_rust_debug.log || echo "No Node.js specific errors found"
        fi

      env:
        NDK_HOME: ${{ env.NDK_HOME }}
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        JAVA_HOME: ${{ env.JAVA_HOME }}

    - name: Build Android APK
      working-directory: ./client
      run: |
        echo "Building Android APK..."
        echo "Checking Android project directory..."

        # Find Android project directory
        ANDROID_PROJECT_DIR=""
        if [ -d "src-tauri/gen/android" ]; then
          ANDROID_PROJECT_DIR="src-tauri/gen/android"
          echo "âœ… Found Android project at: $ANDROID_PROJECT_DIR"
        else
          echo "ðŸ” Searching for Android project directory..."
          ANDROID_PROJECT_DIR=$(find src-tauri -type d -name "*android*" 2>/dev/null | head -1)
          if [ -n "$ANDROID_PROJECT_DIR" ]; then
            echo "âœ… Found Android project at: $ANDROID_PROJECT_DIR"
          else
            echo "âŒ No Android project found, re-initializing..."
            npx tauri android init --ci
            if [ -d "src-tauri/gen/android" ]; then
              ANDROID_PROJECT_DIR="src-tauri/gen/android"
              echo "âœ… Re-initialization successful: $ANDROID_PROJECT_DIR"
            else
              echo "âŒ Re-initialization failed"
              exit 1
            fi
          fi
        fi

        echo "Android project directory contents:"
        ls -la "$ANDROID_PROJECT_DIR"/ 2>/dev/null || echo "Cannot list directory contents"

        echo "Starting Android build..."
        echo "Environment check before build:"
        echo "ANDROID_HOME: $ANDROID_HOME"
        echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"
        echo "NDK_HOME: $NDK_HOME"
        echo "JAVA_HOME: $JAVA_HOME"
        echo "CI: $CI"
        echo "KEYSTORE_PATH: $KEYSTORE_PATH"

        # Set additional environment variables that Tauri might need
        export ANDROID_NDK_ROOT="$NDK_HOME"
        export ANDROID_NDK_HOME="$NDK_HOME"

        echo "Additional environment variables set:"
        echo "ANDROID_NDK_ROOT: $ANDROID_NDK_ROOT"
        echo "ANDROID_NDK_HOME: $ANDROID_NDK_HOME"

        # Try building with more verbose output and error handling
        echo "Building for Android with detailed logging..."
        set -x  # Enable command tracing

        # First, let's try a simple build to see what happens
        echo "=== Starting Tauri Android Build ==="

        # Use the npm script that's defined in package.json
        echo "=== Attempting Tauri Build with Enhanced Error Reporting ==="

        # Run with maximum verbosity and capture all output
        if npm run tauri:android:build -- --verbose 2>&1 | tee android_build.log; then
          BUILD_EXIT_CODE=0
          echo "âœ… Build succeeded with npm run tauri:android:build"
        elif npm run tauri android build -- --verbose 2>&1 | tee android_build.log; then
          BUILD_EXIT_CODE=0
          echo "âœ… Build succeeded with npm run tauri android build"
        elif npx tauri android build --verbose 2>&1 | tee android_build.log; then
          BUILD_EXIT_CODE=0
          echo "âœ… Build succeeded with npx tauri command"
        else
          BUILD_EXIT_CODE=1
          echo "âŒ All build methods failed"

          # Immediately analyze the Gradle failure
          echo "=== GRADLE BUILD FAILURE ANALYSIS ==="

          if [ -d "src-tauri/gen/android" ]; then
            cd src-tauri/gen/android

            echo "=== Running Gradle with maximum verbosity ==="
            ./gradlew assembleRelease --info --stacktrace --debug 2>&1 | tee detailed_gradle.log

            echo "=== Gradle Build File Verification ==="
            echo "--- app/build.gradle.kts content around signingConfigs ---"
            grep -A 10 -B 5 "signingConfigs\|signingConfig" app/build.gradle.kts || echo "No signing config found in build file"

            echo "=== Environment Variables in Gradle Context ==="
            ./gradlew :app:tasks --info 2>&1 | grep -i "environment\|CI\|KEYSTORE\|KEY_" || echo "No environment variable info found"

            echo "=== Last 100 lines of detailed Gradle log ==="
            tail -100 detailed_gradle.log

            cd ../../..
          fi
        fi

        echo "=== Build completed with exit code: $BUILD_EXIT_CODE ==="

        if [ $BUILD_EXIT_CODE -eq 0 ]; then
          echo "âœ… Build succeeded! Looking for APK files..."
          find . -name "*.apk" -type f 2>/dev/null || echo "No APK files found despite successful build"
        else
          echo "âŒ Build failed with exit code $BUILD_EXIT_CODE"
          echo "=== BUILD FAILED - Analyzing logs ==="
          echo "Last 50 lines of build log:"
          tail -50 android_build.log
          echo "=== Checking for common error patterns ==="
          grep -i "error\|failed\|exception" android_build.log | tail -10
          echo "=== Checking Rust compilation logs ==="
          find . -name "*.log" -type f -exec echo "=== {} ===" \; -exec tail -20 {} \; 2>/dev/null || echo "No additional log files found"

          # Don't exit immediately - let's still try to find any partial artifacts
          echo "=== Checking for partial build artifacts ==="
          find . -name "*.so" -o -name "*.a" -o -name "*.apk" -o -name "*.aab" 2>/dev/null | head -10 || echo "No build artifacts found"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}
        JAVA_HOME: ${{ env.JAVA_HOME }}
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}
        # Android signing environment variables (CI mode)
        CI: true
        KEYSTORE_PATH: android/release.keystore
        KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

    - name: Find and Upload APK
      working-directory: ./client
      run: |
        echo "=== Searching for APK files ==="
        echo "Looking for APK files in the workspace..."
        find . -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"

        echo "Checking standard Android build directories:"
        find . -path "*/build/outputs/apk*" -type d 2>/dev/null || echo "No standard APK output directories found"
        find . -path "*/target/*/release*" -type d 2>/dev/null || echo "No Rust target directories found"

        echo "Checking Tauri Android project structure:"
        if [ -d "src-tauri/gen/android" ]; then
          echo "Android project directory structure:"
          find src-tauri/gen/android -type f -name "*.apk" -o -name "*.aab" 2>/dev/null || echo "No APK/AAB files in android directory"

          echo "Full directory structure of Android project:"
          find src-tauri/gen/android -type d | head -20

          echo "Build outputs directory:"
          find src-tauri/gen/android -path "*/build/outputs*" -type d -exec ls -la {} \; 2>/dev/null || echo "No build outputs found"
        fi

        echo "Checking if build actually succeeded..."
        if [ -f "android_build.log" ]; then
          echo "=== Last 20 lines of build log ==="
          tail -20 android_build.log
          echo "=== Searching for APK creation messages ==="
          grep -i "apk\|assembl\|build.*success" android_build.log || echo "No APK creation messages found"
        fi

    - name: Upload APK (if found)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: android-apk
        path: |
          client/src-tauri/gen/android/app/build/outputs/apk/**/*.apk
          client/src-tauri/gen/android/**/build/outputs/apk/**/*.apk
          client/src-tauri/target/**/release/*.apk
          client/**/*.apk
        if-no-files-found: warn

  build-ios:
    name: Build iOS IPA
    runs-on: macos-15  # Use macOS 15 which has Xcode 16+
    needs: test-client
    if: true  # Enable for testing - Tauri 2.x has iOS support
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim

    - name: Verify Xcode Version
      run: |
        echo "=== Xcode Environment Check ==="
        xcodebuild -version
        xcrun --show-sdk-version --sdk iphoneos || echo "iPhone SDK not found"

        # Check Xcode version compatibility
        XCODE_VERSION=$(xcodebuild -version | head -1 | sed 's/Xcode //')
        echo "Detected Xcode version: $XCODE_VERSION"

        # Tauri 2.x typically requires Xcode 15.0+ for iOS builds
        if [[ $(echo "$XCODE_VERSION 15.0" | tr " " "\n" | sort -V | head -1) != "15.0" ]]; then
          echo "âš ï¸  Warning: Xcode version may be too old for Tauri 2.x iOS builds"
          echo "   Detected: $XCODE_VERSION"
          echo "   Required: 15.0 or later"
          echo "   This may cause project format compatibility issues"
        else
          echo "âœ… Xcode version appears compatible"
        fi

    - name: Install Apple Certificates and Provisioning Profiles
      run: |
        echo "ðŸ” Setting up iOS code signing..."

        # Check if we have the required secrets for code signing
        if [ -z "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
          echo "âš ï¸  APPLE_DEVELOPMENT_TEAM secret not found"
          echo "   Code signing will be skipped. The build may fail at signing step."
          echo "   See docs/IOS_CODE_SIGNING_SETUP.md for complete setup instructions."
          export SKIP_CODESIGN=true
        else
          echo "âœ… Apple Developer Team found: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export SKIP_CODESIGN=false
        fi

        if [ "$SKIP_CODESIGN" = "false" ]; then
          echo "ðŸ”‘ Installing certificates and provisioning profiles..."

          # Debug: Check if provisioning profile secrets are available
          echo "ðŸ” Checking provisioning profile secrets availability..."
          if [ -n "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" ]; then
            DEV_PROFILE_LENGTH=$(echo "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" | wc -c)
            echo "âœ… IOS_DEVELOPMENT_PROVISIONING_PROFILE found (length: $DEV_PROFILE_LENGTH chars)"
          else
            echo "âŒ IOS_DEVELOPMENT_PROVISIONING_PROFILE not found"
          fi

          if [ -n "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" ]; then
            DIST_PROFILE_LENGTH=$(echo "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" | wc -c)
            echo "âœ… IOS_DISTRIBUTION_PROVISIONING_PROFILE found (length: $DIST_PROFILE_LENGTH chars)"
          else
            echo "âŒ IOS_DISTRIBUTION_PROVISIONING_PROFILE not found"
          fi

          # Create temporary keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Install development certificate if available
          if [ -n "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" ]; then
            echo "ðŸ“± Installing development certificate..."

            # Debug: Check secret length and first few characters
            SECRET_LENGTH=$(echo "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" | wc -c)
            SECRET_START=$(echo "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" | head -c 50)
            echo "   Secret length: $SECRET_LENGTH characters"
            echo "   Secret starts with: ${SECRET_START}..."

            # Decode certificate
            echo "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" | base64 --decode > development_certificate.p12

            # Check decoded file
            if [ -f "development_certificate.p12" ]; then
              DECODED_SIZE=$(ls -l development_certificate.p12 | awk '{print $5}')
              echo "   Decoded P12 size: $DECODED_SIZE bytes"

              # Check if file is actually a P12
              file development_certificate.p12 || echo "   Cannot determine file type"
            else
              echo "   âŒ Failed to create decoded P12 file"
              exit 1
            fi

            # Test different password approaches
            echo "   Testing password approaches..."

            # Method 1: Direct secret reference
            echo "   Method 1: Direct secret reference"
            if security import development_certificate.p12 -k build.keychain -P "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign 2>&1; then
              echo "   âœ… Method 1 SUCCESS"
              IMPORT_SUCCESS=true
            else
              echo "   âŒ Method 1 FAILED"

              # Method 2: Environment variable
              echo "   Method 2: Environment variable"
              CERT_PASSWORD="${{ secrets.APPLE_CERTIFICATE_PASSWORD }}"
              if security import development_certificate.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign 2>&1; then
                echo "   âœ… Method 2 SUCCESS"
                IMPORT_SUCCESS=true
              else
                echo "   âŒ Method 2 FAILED"

                # Method 3: Quoted password
                echo "   Method 3: Quoted password"
                if security import development_certificate.p12 -k build.keychain -P '${{ secrets.APPLE_CERTIFICATE_PASSWORD }}' -T /usr/bin/codesign 2>&1; then
                  echo "   âœ… Method 3 SUCCESS"
                  IMPORT_SUCCESS=true
                else
                  echo "   âŒ Method 3 FAILED"

                  # Method 4: Empty password test
                  echo "   Method 4: Empty password test"
                  if security import development_certificate.p12 -k build.keychain -P "" -T /usr/bin/codesign 2>&1; then
                    echo "   âœ… Method 4 SUCCESS (empty password)"
                    IMPORT_SUCCESS=true
                  else
                    echo "   âŒ All methods FAILED"
                    echo "   P12 file might be corrupted or incompatible"
                    IMPORT_SUCCESS=false
                  fi
                fi
              fi
            fi

            rm development_certificate.p12

            if [ "$IMPORT_SUCCESS" = true ]; then
              echo "âœ… Development certificate installed successfully"
            else
              echo "âŒ Development certificate installation failed"
              echo "   This might indicate a certificate compatibility issue"
              echo "   or that the certificates were not generated correctly"
            fi
          else
            echo "âš ï¸  Development certificate not found in secrets"
          fi

          # Skip distribution certificate for now to focus on development certificate
          if [ -n "${{ secrets.APPLE_DISTRIBUTION_CERTIFICATE_P12_BASE64 }}" ] && [ "$IMPORT_SUCCESS" = true ]; then
            echo "ðŸª Installing distribution certificate..."
            echo "${{ secrets.APPLE_DISTRIBUTION_CERTIFICATE_P12_BASE64 }}" | base64 --decode > distribution_certificate.p12

            CERT_PASSWORD="${{ secrets.APPLE_CERTIFICATE_PASSWORD }}"
            if security import distribution_certificate.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign 2>&1; then
              echo "âœ… Distribution certificate installed"
            else
              echo "âš ï¸  Distribution certificate installation failed (but continuing)"
            fi
            rm distribution_certificate.p12
          else
            echo "âš ï¸  Distribution certificate not found in secrets or development failed"
          fi

          # Create provisioning profiles directory
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles

          # Install development provisioning profile
          if [ -n "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" ]; then
            echo "ðŸ”§ Installing development provisioning profile..."
            echo "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision

            # Verify the profile was installed correctly
            if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision ]; then
              PROFILE_SIZE=$(ls -l ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision | awk '{print $5}')
              echo "âœ… Development provisioning profile installed (size: $PROFILE_SIZE bytes)"

          # Extract profile UUID for manual code signing
          if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision ]; then
            PROFILE_UUID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision 2>/dev/null | grep -A1 "<key>UUID</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            echo "ðŸ“‹ Development Profile UUID: $PROFILE_UUID"
            echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV

            # Also extract the profile name for manual signing
            PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision 2>/dev/null | grep -A1 "<key>Name</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            echo "ðŸ“‹ Development Profile Name: $PROFILE_NAME"
            echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_ENV
          fi
            else
              echo "âŒ Development provisioning profile file was not created"
            fi
          else
            echo "âš ï¸  Development provisioning profile not found in secrets"
          fi

          # Install distribution provisioning profile
          if [ -n "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" ]; then
            echo "ðŸ“¦ Installing distribution provisioning profile..."
            echo "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision

            # Verify the profile was installed correctly
            if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision ]; then
              PROFILE_SIZE=$(ls -l ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision | awk '{print $5}')
              echo "âœ… Distribution provisioning profile installed (size: $PROFILE_SIZE bytes)"
            else
              echo "âŒ Distribution provisioning profile file was not created"
            fi
          else
            echo "âš ï¸  Distribution provisioning profile not found in secrets"
          fi

          # Set partition list to avoid permission issues
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" build.keychain

          echo "ðŸ” Verifying code signing setup..."
          echo "Available signing identities:"
          security find-identity -v -p codesigning | head -10

          echo "Installed provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No profiles directory found"

          echo "Profile details:"
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if [ -f "$profile" ]; then
              echo "--- $(basename "$profile") ---"
              # Extract more detailed information about the profile
              PROFILE_CONTENT=$(security cms -D -i "$profile" 2>/dev/null)
              echo "$PROFILE_CONTENT" | grep -E "TeamName|AppIDName|UUID|application-identifier" | head -10 || echo "Could not read profile"

              # Check if this profile matches our bundle ID
              BUNDLE_ID_MATCH=$(echo "$PROFILE_CONTENT" | grep -A1 "application-identifier" | grep "com.beout.app")
              if [ -n "$BUNDLE_ID_MATCH" ]; then
                echo "âœ… This profile matches bundle ID: com.beout.app"
                echo "   Bundle ID pattern: $BUNDLE_ID_MATCH"
              else
                echo "âŒ This profile does NOT match bundle ID: com.beout.app"
                ACTUAL_BUNDLE=$(echo "$PROFILE_CONTENT" | grep -A1 "application-identifier" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
                echo "   Actual bundle ID pattern: $ACTUAL_BUNDLE"
              fi
            fi
          done

          echo "âœ… Code signing setup completed"
        else
          echo "â­ï¸  Skipping code signing setup (no certificates configured)"
        fi
      env:
        APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

    - name: Install Tauri CLI
      run: |
        echo "Installing Tauri CLI..."

        # Try to install the latest version first
        if npm install -g @tauri-apps/cli@latest; then
          TAURI_VERSION=$(npm list -g @tauri-apps/cli --depth=0 | grep @tauri-apps/cli)
          echo "âœ… Installed: $TAURI_VERSION"
        else
          echo "âŒ Failed to install latest Tauri CLI"
          exit 1
        fi

        echo "Verifying Tauri CLI installation..."
        tauri --version || echo "Failed to get Tauri version"

        echo "Installing Tauri CLI locally as well..."
        npm install @tauri-apps/cli@latest

    - name: Install dependencies
      run: npm ci

    - name: Build client
      run: npm run build:client
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}

    - name: Initialize iOS project
      working-directory: ./client
      run: |
        echo "Initializing Tauri iOS project..."
        echo "Available npm scripts in client directory:"
        npm run | grep tauri || echo "No tauri scripts found"

        # Fix Google Auth plugin iOS issue
        echo "ðŸ”§ Fixing tauri-plugin-google-auth iOS configuration..."
        if [ ! -d "../tauri-plugin-google-auth/ios" ]; then
          echo "Creating missing iOS directory for Google Auth plugin..."
          mkdir -p ../tauri-plugin-google-auth/ios/Sources
          
          # Create a minimal Package.swift
          echo '// swift-tools-version:5.3' > ../tauri-plugin-google-auth/ios/Package.swift
          echo 'import PackageDescription' >> ../tauri-plugin-google-auth/ios/Package.swift
          echo '' >> ../tauri-plugin-google-auth/ios/Package.swift
          echo 'let package = Package(' >> ../tauri-plugin-google-auth/ios/Package.swift
          echo '    name: "tauri-plugin-google-auth",' >> ../tauri-plugin-google-auth/ios/Package.swift
          echo '    platforms: [.iOS(.v12)],' >> ../tauri-plugin-google-auth/ios/Package.swift
          echo '    products: [.library(name: "tauri-plugin-google-auth", targets: ["tauri-plugin-google-auth"])],' >> ../tauri-plugin-google-auth/ios/Package.swift
          echo '    targets: [.target(name: "tauri-plugin-google-auth", path: "Sources")]' >> ../tauri-plugin-google-auth/ios/Package.swift
          echo ')' >> ../tauri-plugin-google-auth/ios/Package.swift

          # Create a basic Swift file
          echo 'import Foundation' > ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          echo 'import UIKit' >> ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          echo '' >> ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          echo '@objc public class GoogleAuthPlugin: NSObject {' >> ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          echo '    @objc public static func setup() {' >> ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          echo '        print("Google Auth Plugin - iOS setup placeholder")' >> ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          echo '    }' >> ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          echo '}' >> ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift
          
          echo "âœ… Created iOS plugin structure with placeholders"
        else
          echo "âœ… iOS directory already exists"
        fi

        # Try different methods to initialize iOS project
        if npm run tauri:ios:init -- --ci; then
          echo "âœ… iOS project initialized with npm script"
        elif npx tauri ios init --ci; then
          echo "âœ… iOS project initialized with npx tauri"
        else
          echo "âŒ All initialization methods failed"
          echo "Checking available Tauri commands..."
          npx tauri --help || echo "No help available"
        fi

        echo "Checking for generated iOS/Apple project..."
        find . -name "*ios*" -o -name "*apple*" -type d 2>/dev/null || echo "No iOS/Apple directories found"

        # Check for both ios and apple directories (Tauri uses 'apple' for iOS/macOS)
        if [ -d "src-tauri/gen/ios" ]; then
          echo "âœ… iOS project created successfully at src-tauri/gen/ios"
          ls -la src-tauri/gen/ios/
        elif [ -d "src-tauri/gen/apple" ]; then
          echo "âœ… Apple project created successfully at src-tauri/gen/apple"
          ls -la src-tauri/gen/apple/
        else
          echo "âŒ iOS/Apple project directory not found"
          echo "Searching for alternative iOS/Apple paths..."
          find src-tauri -type d -name "*ios*" -o -name "*apple*" 2>/dev/null || echo "No iOS/Apple directories found"
        fi

    - name: Build iOS IPA
      working-directory: ./client
      run: |
        echo "Building iOS IPA..."
        echo "Checking iOS project directory..."

        # Find iOS project directory (Tauri uses 'apple' directory for iOS/macOS)
        IOS_PROJECT_DIR=""
        if [ -d "src-tauri/gen/ios" ]; then
          IOS_PROJECT_DIR="src-tauri/gen/ios"
          echo "âœ… Found iOS project at: $IOS_PROJECT_DIR"
        elif [ -d "src-tauri/gen/apple" ]; then
          IOS_PROJECT_DIR="src-tauri/gen/apple"
          echo "âœ… Found Apple project at: $IOS_PROJECT_DIR"
        else
          echo "ðŸ” Searching for iOS/Apple project directory..."
          IOS_PROJECT_DIR=$(find src-tauri -type d -name "*ios*" -o -name "*apple*" 2>/dev/null | head -1)
          if [ -n "$IOS_PROJECT_DIR" ]; then
            echo "âœ… Found iOS/Apple project at: $IOS_PROJECT_DIR"
          else
            echo "âŒ No iOS/Apple project found, re-initializing..."
            if npx tauri ios init --ci; then
              if [ -d "src-tauri/gen/ios" ]; then
                IOS_PROJECT_DIR="src-tauri/gen/ios"
                echo "âœ… Re-initialization successful: $IOS_PROJECT_DIR"
              elif [ -d "src-tauri/gen/apple" ]; then
                IOS_PROJECT_DIR="src-tauri/gen/apple"
                echo "âœ… Re-initialization successful: $IOS_PROJECT_DIR"
              else
                echo "âŒ Re-initialization failed"
                exit 1
              fi
            else
              echo "âŒ Re-initialization failed"
              exit 1
            fi
          fi
        fi

        echo "iOS/Apple project directory contents:"
        ls -la "$IOS_PROJECT_DIR"/ 2>/dev/null || echo "Cannot list directory contents"

        echo "Starting iOS build..."

        # Set up code signing environment variables
        if [ -n "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
          echo "ðŸ” Code signing enabled with Team ID: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export APPLE_DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export APPLE_TEAM_ID="${{ secrets.APPLE_DEVELOPMENT_TEAM }}"

          # Use manual code signing with specific profile
          export CODE_SIGN_IDENTITY="iPhone Developer"
          export CODE_SIGN_STYLE="Manual"
          export DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export PRODUCT_BUNDLE_IDENTIFIER="com.beout.app"

          # Set the provisioning profile if we extracted it
          if [ -n "$PROFILE_UUID" ]; then
            export PROVISIONING_PROFILE="$PROFILE_UUID"
            echo "  Provisioning Profile UUID: $PROFILE_UUID"
          fi
          if [ -n "$PROFILE_NAME" ]; then
            export PROVISIONING_PROFILE_SPECIFIER="$PROFILE_NAME"
            echo "  Provisioning Profile Name: $PROFILE_NAME"
          fi

          echo "Code signing configuration:"
          echo "  Team ID: $APPLE_DEVELOPMENT_TEAM"
          echo "  Bundle ID: $PRODUCT_BUNDLE_IDENTIFIER"
          echo "  Identity: $CODE_SIGN_IDENTITY"
          echo "  Style: $CODE_SIGN_STYLE (Manual - using specific profile)"
        else
          echo "âš ï¸  Warning: No code signing certificates configured."
          echo "   The build will attempt to proceed but may fail at the signing step."
          echo "   Add the required secrets to enable code signing:"
          echo "   - APPLE_DEVELOPMENT_TEAM"
          echo "   - APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64"
          echo "   - APPLE_DEVELOPMENT_PROVISIONING_PROFILE_BASE64"
          echo "   - APPLE_CERTIFICATE_PASSWORD"
          echo ""
          echo "   See docs/IOS_CODE_SIGNING_SETUP.md for complete setup instructions."
        fi

    - name: Configure iOS Xcode Project
      working-directory: ./client
      run: |
        # Try different methods to build iOS
        echo "=== Attempting Tauri iOS Build ==="

        # Debug Xcode project first
        echo "ðŸ” Looking for Xcode project..."
        find src-tauri/gen/apple -name "*.xcodeproj" -o -name "*.xcworkspace" 2>/dev/null || echo "No Xcode project found yet"

        echo ""
        echo "ðŸ” Checking tauri directory structure..."
        ls -la src-tauri/ || echo "No src-tauri directory"
        ls -la src-tauri/gen/ 2>/dev/null || echo "No src-tauri/gen directory"
        ls -la src-tauri/gen/apple/ 2>/dev/null || echo "No src-tauri/gen/apple directory"

        echo ""
        echo "ðŸ” Checking for any .xcodeproj files..."
        find . -name "*.xcodeproj" -type d 2>/dev/null || echo "No .xcodeproj files found"

        # Initialize iOS project if needed
        echo ""
        echo "ðŸš€ Ensuring iOS project is initialized..."
        if [ ! -d "src-tauri/gen/apple" ]; then
          echo "ðŸ“± Initializing iOS project..."
          npx tauri ios init || echo "iOS init failed or already done"
        else
          echo "âœ… iOS project directory already exists"
        fi

        # Check if we now have an Xcode project
        echo ""
        echo "ðŸ” Post-init: Looking for Xcode project..."
        find src-tauri/gen/apple -name "*.xcodeproj" -o -name "*.xcworkspace" 2>/dev/null || echo "Still no Xcode project found"

        # Configure Xcode project for manual code signing
        echo ""
        echo "ðŸ”§ Configuring Xcode project for manual code signing..."
        if [ -f "src-tauri/gen/apple/app.xcodeproj/project.pbxproj" ]; then
          echo "ðŸ“ Updating Xcode project settings..."

          # Make a backup first
          cp src-tauri/gen/apple/app.xcodeproj/project.pbxproj src-tauri/gen/apple/app.xcodeproj/project.pbxproj.backup

          # Update the project.pbxproj file to use manual code signing
          # This is more reliable than environment variables for Xcode projects
          sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          sed -i '' 's/CODE_SIGN_IDENTITY = "Apple Development";/CODE_SIGN_IDENTITY = "iPhone Developer";/g' src-tauri/gen/apple/app.xcodeproj/project.pbxproj

          # Add DEVELOPMENT_TEAM to all build configurations
          if [ -n "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
            # Set DEVELOPMENT_TEAM for all configurations
            sed -i '' "s/DEVELOPMENT_TEAM = \"\";/DEVELOPMENT_TEAM = \"${{ secrets.APPLE_DEVELOPMENT_TEAM }}\";/g" src-tauri/gen/apple/app.xcodeproj/project.pbxproj
            sed -i '' "s/DEVELOPMENT_TEAM = [^;]*;/DEVELOPMENT_TEAM = \"${{ secrets.APPLE_DEVELOPMENT_TEAM }}\";/g" src-tauri/gen/apple/app.xcodeproj/project.pbxproj

            # Add DEVELOPMENT_TEAM if it doesn't exist using printf
            if ! grep -q "DEVELOPMENT_TEAM" src-tauri/gen/apple/app.xcodeproj/project.pbxproj; then
              # Use printf to add the line with proper formatting
              printf '\t\t\t\tDEVELOPMENT_TEAM = "%s";\n' "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" > /tmp/dev_team_line
              sed -i '' '/buildSettings = {/r /tmp/dev_team_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
              rm /tmp/dev_team_line
            fi
          fi

          # Force CODE_SIGN_STYLE to Manual everywhere
          printf '\t\t\t\tCODE_SIGN_STYLE = Manual;\n' > /tmp/code_sign_line
          sed -i '' '/buildSettings = {/r /tmp/code_sign_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          rm /tmp/code_sign_line

          # Set explicit architecture for iOS device builds
          printf '\t\t\t\tARCHS = arm64;\n' > /tmp/archs_line
          printf '\t\t\t\tVALID_ARCHS = arm64;\n' > /tmp/valid_archs_line
          sed -i '' '/buildSettings = {/r /tmp/archs_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          sed -i '' '/buildSettings = {/r /tmp/valid_archs_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          rm /tmp/archs_line /tmp/valid_archs_line

          # Add the provisioning profile settings
          if [ -n "$PROFILE_UUID" ]; then
            echo "ðŸ“‹ Adding provisioning profile settings: $PROFILE_UUID"
            
            # Add provisioning profile settings using printf
            printf '\t\t\t\tPROVISIONING_PROFILE = "%s";\n' "$PROFILE_UUID" > /tmp/profile_uuid_line
            printf '\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = "%s";\n' "$PROFILE_NAME" > /tmp/profile_name_line
            
            sed -i '' '/buildSettings = {/r /tmp/profile_uuid_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
            sed -i '' '/buildSettings = {/r /tmp/profile_name_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
            
            rm /tmp/profile_uuid_line /tmp/profile_name_line
          fi

          echo "âœ… Xcode project configured for manual code signing"
          echo "ðŸ“‹ Verifying project settings..."
          grep -A 2 -B 2 "CODE_SIGN_STYLE\|PROVISIONING_PROFILE\|DEVELOPMENT_TEAM" src-tauri/gen/apple/app.xcodeproj/project.pbxproj | head -15
        else
          echo "âš ï¸ Xcode project file not found, manual configuration skipped"
        fi

    - name: Verify iOS Code Signing Setup
      working-directory: ./client
      run: |
        # Verify the final Xcode project configuration
        echo ""
        echo "ðŸ” Final verification of Xcode project configuration..."
        if [ -f "src-tauri/gen/apple/app.xcodeproj/project.pbxproj" ]; then
          echo "ðŸ“‹ Code signing settings in Xcode project:"
          grep -n "CODE_SIGN_STYLE\|CODE_SIGN_IDENTITY\|PROVISIONING_PROFILE\|DEVELOPMENT_TEAM" src-tauri/gen/apple/app.xcodeproj/project.pbxproj | head -20

          echo ""
          echo "ðŸ“‹ Bundle identifier settings:"
          grep -n "PRODUCT_BUNDLE_IDENTIFIER" src-tauri/gen/apple/app.xcodeproj/project.pbxproj | head -5

          echo ""
          echo "ðŸ“‹ Detailed verification of manual code signing configuration:"
          echo "   Looking for manual CODE_SIGN_STYLE entries:"
          grep -n "CODE_SIGN_STYLE.*Manual" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   âŒ No manual code signing found"

          echo "   Looking for DEVELOPMENT_TEAM entries:"
          grep -n "DEVELOPMENT_TEAM.*${{ secrets.APPLE_DEVELOPMENT_TEAM }}" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   âŒ No development team found"

          echo "   Looking for PROVISIONING_PROFILE entries:"
          grep -n "PROVISIONING_PROFILE.*$PROFILE_UUID" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   âŒ No provisioning profile UUID found"

          echo "   Looking for PROVISIONING_PROFILE_SPECIFIER entries:"
          grep -n "PROVISIONING_PROFILE_SPECIFIER.*$PROFILE_NAME" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   âŒ No provisioning profile specifier found"
        fi

        # Verify provisioning profiles one more time
        echo ""
        echo "ðŸ” Final verification of installed provisioning profiles..."
        ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No profiles directory found"

        echo ""
        echo "ðŸ“‹ Detailed analysis of installed provisioning profiles:"
        for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
          if [ -f "$profile" ]; then
            echo "--- Profile: $(basename "$profile") ---"
            PROFILE_CONTENT=$(security cms -D -i "$profile" 2>/dev/null)

            # Extract key information
            PROFILE_UUID_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "<key>UUID</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            PROFILE_NAME_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "<key>Name</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            BUNDLE_ID_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "application-identifier" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            TEAM_ID_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "<key>TeamIdentifier</key>" -A2 | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')

            echo "  UUID: $PROFILE_UUID_CHECK"
            echo "  Name: $PROFILE_NAME_CHECK"
            echo "  Bundle ID pattern: $BUNDLE_ID_CHECK"
            echo "  Team ID: $TEAM_ID_CHECK"

            # Check if this matches our expected values
            if [ "$PROFILE_UUID_CHECK" = "$PROFILE_UUID" ]; then
              echo "  âœ… This profile matches our PROFILE_UUID"
            else
              echo "  âŒ This profile does NOT match our PROFILE_UUID ($PROFILE_UUID)"
            fi

            if [[ "$BUNDLE_ID_CHECK" == *"com.beout.app"* ]]; then
              echo "  âœ… This profile matches bundle ID com.beout.app"
            else
              echo "  âŒ This profile does NOT match bundle ID com.beout.app"
            fi

            if [ "$TEAM_ID_CHECK" = "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
              echo "  âœ… This profile matches our team ID"
            else
              echo "  âŒ This profile does NOT match our team ID (${{ secrets.APPLE_DEVELOPMENT_TEAM }})"
            fi
            echo ""
          fi
        done

        echo ""
        echo "ðŸ“‹ Available signing identities before build:"
        security find-identity -v -p codesigning | head -5

    - name: Execute iOS Build
      working-directory: ./client
      run: |
        # Configure Cargo for better CI performance
        echo ""
        echo "ðŸ”§ Configuring Cargo for CI environment..."
        mkdir -p ~/.cargo
        cat > ~/.cargo/config.toml << 'EOF'
        [net]
        retry = 10

        [http]
        timeout = 300
        multiplexing = false

        [build]
        jobs = 2

        [net.git]
        fetch-with-cli = true
        EOF

        echo "âœ… Cargo configuration complete"
        echo "ðŸ“‹ Cargo config:"
        cat ~/.cargo/config.toml

        # Pre-warm Cargo cache to reduce build time
        echo ""
        echo "ðŸ”¥ Pre-warming Cargo cache..."
        cd src-tauri
        
        # Use a background process with timeout since macOS doesn't have timeout by default
        # Note: Use aarch64-apple-ios for Rust, but aarch64 for Tauri CLI
        cargo fetch --target aarch64-apple-ios &
        FETCH_PID=$!
        
        # Wait up to 600 seconds (10 minutes) for cargo fetch
        COUNTER=0
        while [ $COUNTER -lt 600 ]; do
          if ! kill -0 $FETCH_PID 2>/dev/null; then
            wait $FETCH_PID
            FETCH_EXIT_CODE=$?
            if [ $FETCH_EXIT_CODE -eq 0 ]; then
              echo "âœ… Cargo fetch completed successfully"
            else
              echo "âš ï¸ Cargo fetch completed with exit code: $FETCH_EXIT_CODE"
            fi
            break
          fi
          sleep 5
          COUNTER=$((COUNTER + 5))
        done
        
        # If still running after timeout, kill it
        if kill -0 $FETCH_PID 2>/dev/null; then
          echo "âš ï¸ Cargo fetch timed out after 10 minutes, terminating..."
          kill $FETCH_PID 2>/dev/null || true
          wait $FETCH_PID 2>/dev/null || true
        fi
        
        cd ..

        # Method 1: npm script with proper exit code handling
        echo "ðŸš€ Trying npm run tauri:ios:build..."
        
        # Set Rust/Cargo optimizations for CI
        export CARGO_NET_RETRY=10
        export CARGO_NET_TIMEOUT=300
        export CARGO_HTTP_TIMEOUT=300
        export CARGO_HTTP_MULTIPLEXING=false
        export CARGO_NET_GIT_FETCH_WITH_CLI=true
        
        # Add timeout and memory monitoring
        echo "ðŸ“Š System resources before build:"
        echo "Available memory:"
        vm_stat | grep "Pages free\|Pages active\|Pages inactive\|Pages speculative\|Pages wired"
        echo "Available disk space:"
        df -h /
        
        # Start a background process to monitor build progress
        (
          sleep 60
          while true; do
            echo "â±ï¸ Build still running... $(date)"
            echo "ðŸ“Š Current memory usage:"
            vm_stat | grep "Pages free" | head -1
            echo "ðŸ“Š Build log size: $(wc -l < ios_build.log 2>/dev/null || echo 0) lines"
            sleep 300  # Log every 5 minutes
          done
        ) &
        MONITOR_PID=$!
        
        # Try the build without background process first to see immediate errors
        echo "ðŸš€ Starting iOS build (initial attempt without timeout)..."
        BUILD_SUCCESS=false
        if npm run tauri:ios:build -- --verbose --target aarch64 2>&1 | tee ios_build.log; then
          echo "âœ… Build succeeded with npm script"
          BUILD_SUCCESS=true
          BUILD_EXIT_CODE=0
        else
          BUILD_EXIT_CODE=$?
          echo "âŒ npm script failed with exit code: $BUILD_EXIT_CODE"
          echo "ðŸ“‹ Build log content:"
          tail -30 ios_build.log
          
          # If it fails immediately, try without arguments
          echo ""
          echo "ðŸš€ Trying npm run tauri:ios:build without arguments..."
          if npm run tauri:ios:build 2>&1 | tee ios_build2.log; then
            echo "âœ… Build succeeded with npm script (no args)"
            BUILD_SUCCESS=true
            BUILD_EXIT_CODE=0
          else
            BUILD_EXIT_CODE2=$?
            echo "âŒ npm script also failed without args, exit code: $BUILD_EXIT_CODE2"
            echo "ðŸ“‹ Second build log content:"
            tail -30 ios_build2.log

            # Method 2: Try npx tauri directly with explicit target
            echo ""
            echo "ðŸš€ Trying npx tauri ios build with explicit target..."
            
            if npx tauri ios build --verbose --target aarch64 2>&1 | tee ios_build3.log; then
              echo "âœ… Build succeeded with npx tauri"
              BUILD_SUCCESS=true
              BUILD_EXIT_CODE=0
            else
              BUILD_EXIT_CODE3=$?
              echo "âŒ npx tauri also failed with exit code: $BUILD_EXIT_CODE3"
              echo "ðŸ“‹ Third build log content:"
              tail -30 ios_build3.log

              # Method 3: Try without target specification (let Tauri decide)
              echo ""
              echo "ðŸš€ Trying npx tauri ios build without target..."
              
              if npx tauri ios build --verbose 2>&1 | tee ios_build4.log; then
                echo "âœ… Build succeeded with npx tauri (no target)"
                BUILD_SUCCESS=true
                BUILD_EXIT_CODE=0
              else
                BUILD_EXIT_CODE4=$?
                echo "âŒ All build methods failed"
                echo "ðŸ“‹ Fourth build log content:"
                tail -30 ios_build4.log
                BUILD_SUCCESS=false
                BUILD_EXIT_CODE=$BUILD_EXIT_CODE4
              fi
            fi
          fi
        fi
        
        # Stop the monitoring process
        kill $MONITOR_PID 2>/dev/null || true

        # Ensure BUILD_SUCCESS is properly set
        if [ -z "$BUILD_SUCCESS" ]; then
          BUILD_SUCCESS=false
        fi

        if [ "$BUILD_SUCCESS" = true ]; then
          echo "âœ… Build completed! Looking for IPA files..."
          echo "=== Searching for IPA files ==="
          find . -name "*.ipa" -type f 2>/dev/null || echo "No IPA files found"

          echo "=== Searching for app bundles ==="
          find . -name "*.app" -type d 2>/dev/null | head -5 || echo "No .app bundles found"

          echo "=== Checking Xcode build directories ==="
          find . -path "*/Build/Products/*" -type f 2>/dev/null | head -10 || echo "No Xcode build products found"

        else
          echo "=== BUILD FAILED - Analyzing logs ==="
          echo "Final exit code: $BUILD_EXIT_CODE"
          
          # Check all log files that might exist
          for log_file in ios_build.log ios_build2.log ios_build3.log ios_build4.log; do
            if [ -f "$log_file" ]; then
              echo ""
              echo "=== Analysis of $log_file ==="
              echo "Last 50 lines of $log_file:"
              tail -50 "$log_file"
              echo ""
              echo "=== Checking for common error patterns in $log_file ==="
              grep -i "error\|failed\|exception" "$log_file" | tail -10
              echo ""
              echo "=== Checking for code signing issues in $log_file ==="
              grep -i "sign\|certificate\|team\|provision\|identity" "$log_file" | tail -10
              echo ""
              echo "=== Checking for Xcode project format issues in $log_file ==="
              grep -i "project.*format\|future.*xcode\|adjust.*project.*format" "$log_file" | tail -5
            fi
          done

          # Check for specific errors and provide guidance based on first log file
          if [ -f "ios_build.log" ] && grep -q "No signing certificate" ios_build.log; then
            echo ""
            echo "ðŸ”§ CODE SIGNING ISSUE DETECTED:"
            echo "   No valid signing certificate found."
            echo "   Solutions:"
            echo "   1. Ensure certificates are properly configured in GitHub Secrets"
            echo "   2. Check that APPLE_DEVELOPMENT_TEAM is set correctly"
            echo "   3. Verify certificates haven't expired"
            echo "   4. See docs/IOS_CODE_SIGNING_SETUP.md for setup instructions"
          fi

          if [ -f "ios_build.log" ] && grep -q "tauri-plugin-google-auth.*build-script-build.*exit status: 101" ios_build.log; then
            echo ""
            echo "ðŸ”§ TAURI GOOGLE AUTH PLUGIN ISSUE DETECTED:"
            echo "   The tauri-plugin-google-auth is failing to build for iOS."
            echo "   This is likely due to missing iOS frameworks or build configuration."
            echo "   Solutions:"
            echo "   1. Temporarily disable the Google Auth plugin for iOS builds"
            echo "   2. Check if the plugin supports iOS in current version"
            echo "   3. Verify plugin configuration for mobile platforms"
            echo "   4. Consider using conditional compilation for mobile vs desktop"
            echo ""
            echo "   Error details from build log:"
            grep -A 5 -B 5 "tauri-plugin-google-auth" ios_build.log | tail -15
          fi

          if [ -f "ios_build.log" ] && grep -q "link_xcode_library\|No such file or directory.*Os.*code: 2" ios_build.log; then
            echo ""
            echo "ðŸ”§ iOS LIBRARY LINKING ISSUE DETECTED:"
            echo "   A Tauri plugin is trying to link against an iOS library that doesn't exist."
            echo "   This often happens with plugins not fully configured for iOS."
            echo "   Solutions:"
            echo "   1. Check which plugin is causing the issue (likely Google Auth)"
            echo "   2. Disable problematic plugins for iOS builds"
            echo "   3. Update plugin to a version with iOS support"
            echo "   4. Add conditional compilation flags"
          fi

          if [ -f "ios_build.log" ] && grep -q "future Xcode project file format" ios_build.log; then
            echo ""
            echo "ðŸ”§ XCODE PROJECT FORMAT ISSUE DETECTED:"
            echo "   The generated iOS project uses a newer format than this Xcode version supports."
            echo "   Solutions:"
            echo "   1. Update to a newer macOS runner (using macos-15)"
            echo "   2. Use an older Tauri CLI version that generates compatible projects"
            echo "   3. Update the GitHub Actions runner to use Xcode 16+"
          fi

          if [ -f "ios_build.log" ] && grep -q "Provisioning profile.*doesn't include signing certificate" ios_build.log; then
            echo ""
            echo "ðŸ”§ PROVISIONING PROFILE MISMATCH:"
            echo "   The provisioning profile doesn't include the signing certificate."
            echo "   Solutions:"
            echo "   1. Regenerate the provisioning profile with the correct certificate"
            echo "   2. Ensure the certificate and profile were created with the same Apple ID"
            echo "   3. Check that the bundle ID matches exactly"
          fi

          # Check for npm script issues
          if [ -f "ios_build.log" ] && grep -q "Unknown command" ios_build.log; then
            echo ""
            echo "ðŸ”§ NPM SCRIPT ISSUE DETECTED:"
            echo "   The npm script might not be properly configured."
            echo "   This could be due to package.json script definition or argument passing."
          fi

          echo ""
          echo "=== Expected Behavior ==="
          echo "iOS builds in CI typically fail at code signing without proper certificates."
          echo "If you see code signing errors, that's expected without proper setup."
          echo "Complete the setup in docs/IOS_CODE_SIGNING_SETUP.md to enable signing."
        fi
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}
        APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
        CODE_SIGN_IDENTITY: "iPhone Developer"
        CODE_SIGN_STYLE: "Manual"
        DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
        PRODUCT_BUNDLE_IDENTIFIER: "com.beout.app"
        PROVISIONING_PROFILE: ${{ env.PROFILE_UUID }}
        PROVISIONING_PROFILE_SPECIFIER: ${{ env.PROFILE_NAME }}

    - name: Find and Upload IPA
      working-directory: ./client
      if: always()
      run: |
        echo "=== Searching for IPA files ==="
        find . -name "*.ipa" -type f 2>/dev/null || echo "No IPA files found"

        echo "=== Searching for app bundles ==="
        find . -name "*.app" -type d 2>/dev/null | head -5 || echo "No .app bundles found"

        echo "=== Checking Xcode build directories ==="
        find . -path "*/Build/Products/*" -type f 2>/dev/null | head -10 || echo "No Xcode build products found"

    - name: Upload IPA (if found)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: ios-ipa
        path: |
          client/src-tauri/gen/ios/**/Build/Products/**/*.ipa
          client/src-tauri/gen/apple/**/Build/Products/**/*.ipa
          client/src-tauri/target/**/release/*.ipa
          client/**/*.ipa
        if-no-files-found: warn

    - name: Cleanup Keychain
      if: always()
      run: |
        echo "ðŸ§¹ Cleaning up keychain..."
        if [ -n "$KEYCHAIN_PASSWORD" ]; then
          security delete-keychain build.keychain || echo "Keychain already deleted or not found"
        fi
        echo "âœ… Cleanup completed"
      env:
        KEYCHAIN_PASSWORD: ${{ env.KEYCHAIN_PASSWORD }}

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-android, build-ios]  # Now depends on both builds
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
    - uses: actions/checkout@v4

    - name: Download Android APK
      uses: actions/download-artifact@v4
      with:
        name: android-apk
        path: ./artifacts/
      continue-on-error: true

    - name: Download iOS IPA
      uses: actions/download-artifact@v4
      with:
        name: ios-ipa
        path: ./artifacts/
      continue-on-error: true

    - name: List artifacts
      run: |
        echo "Available artifacts:"
        find ./artifacts -type f -name "*.apk" -o -name "*.ipa" 2>/dev/null || echo "No APK or IPA files found"
        ls -la ./artifacts/ 2>/dev/null || echo "No artifacts directory"

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ./artifacts/*.apk
          ./artifacts/*.ipa
        draft: true
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
