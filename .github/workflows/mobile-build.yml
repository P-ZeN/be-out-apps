name: Mobile App Build and Release

on:
  push:
    branches: [ mobile-build ]  # Only run on mobile-build branch
    paths:  # Only run when these files change
      - 'client/**'
      - '.github/workflows/mobile-build.yml'
      - 'package.json'
      - 'package-lock.json'
  pull_request:
    branches: [ mobile-build ]  # Only run PR checks when targeting mobile-build branch
    paths:  # Only run when these files change
      - 'client/**'
      - '.github/workflows/mobile-build.yml'
      - 'package.json'
      - 'package-lock.json'
  workflow_dispatch:  # Allow manual triggering from GitHub UI

env:
  CARGO_TERM_COLOR: always

jobs:
  test-client:
    name: Test Client App
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'
    - name: Install dependencies
      run: npm ci
    - name: Build client
      run: npm run build:client
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}
    - name: Test client
      run: npm run test --workspace=client --if-present

  build-android:
    name: Build Android APK
    runs-on: ubuntu-latest
    needs: test-client
    if: true  # Enabled
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Setup Java JDK
      uses: actions/setup-java@v4
      with:
        distribution: 'temurin'
        java-version: '17'

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-linux-android,armv7-linux-androideabi,x86_64-linux-android,i686-linux-android

    - name: Install Rust targets for Android
      run: |
        echo "Installing Android targets..."
        rustup target add aarch64-linux-android
        rustup target add armv7-linux-androideabi
        rustup target add x86_64-linux-android
        rustup target add i686-linux-android
        echo "Installed targets:"
        rustup target list --installed | grep android

    - name: Setup Android SDK
      uses: android-actions/setup-android@v3
      with:
        api-level: 33
        build-tools: 33.0.0
        ndk-version: 25.2.9519653

    - name: Verify Android Environment
      run: |
        echo "Android SDK Root: $ANDROID_SDK_ROOT"
        echo "NDK Home: $ANDROID_SDK_ROOT/ndk/25.2.9519653"
        echo "Java Home: $JAVA_HOME"
        ls -la $ANDROID_SDK_ROOT/ndk/ || echo "NDK directory not found"
        # Find actual NDK directory
        if [ -d "$ANDROID_SDK_ROOT/ndk" ]; then
          echo "Available NDK versions:"
          ls -la $ANDROID_SDK_ROOT/ndk/
          NDK_DIR=$(ls -1 $ANDROID_SDK_ROOT/ndk/ | head -1)
          echo "Using NDK: $NDK_DIR"
          echo "NDK_HOME=$ANDROID_SDK_ROOT/ndk/$NDK_DIR" >> $GITHUB_ENV
        fi

    - name: Configure Cargo for Android
      run: |
        echo "Setting up Cargo configuration for Android builds..."
        echo "Using NDK_HOME: $NDK_HOME"
        mkdir -p ~/.cargo

        # Verify NDK tools exist before creating config
        NDK_TOOLCHAIN="$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin"
        echo "Checking NDK toolchain at: $NDK_TOOLCHAIN"

        if [ ! -d "$NDK_TOOLCHAIN" ]; then
          echo "‚ùå NDK toolchain directory not found: $NDK_TOOLCHAIN"
          echo "Available NDK contents:"
          find "$NDK_HOME" -type d -name "bin" 2>/dev/null | head -5
          exit 1
        fi

        # Find the correct Android API level linkers
        echo "Looking for Android clang linkers..."
        AARCH64_LINKER=$(find "$NDK_TOOLCHAIN" -name "*aarch64*android*clang" | head -1)
        ARMV7_LINKER=$(find "$NDK_TOOLCHAIN" -name "*armv7*android*clang" -o -name "*arm*android*clang" | head -1)
        X86_64_LINKER=$(find "$NDK_TOOLCHAIN" -name "*x86_64*android*clang" | head -1)
        I686_LINKER=$(find "$NDK_TOOLCHAIN" -name "*i686*android*clang" | head -1)

        echo "Found linkers:"
        echo "AARCH64: $AARCH64_LINKER"
        echo "ARMV7: $ARMV7_LINKER"
        echo "X86_64: $X86_64_LINKER"
        echo "I686: $I686_LINKER"

        # Use found linkers or fallback to API level 21
        AARCH64_LINKER=${AARCH64_LINKER:-"$NDK_TOOLCHAIN/aarch64-linux-android21-clang"}
        ARMV7_LINKER=${ARMV7_LINKER:-"$NDK_TOOLCHAIN/armv7a-linux-androideabi21-clang"}
        X86_64_LINKER=${X86_64_LINKER:-"$NDK_TOOLCHAIN/x86_64-linux-android21-clang"}
        I686_LINKER=${I686_LINKER:-"$NDK_TOOLCHAIN/i686-linux-android21-clang"}

        # Create Cargo config with discovered linkers
        cat > ~/.cargo/config.toml << 'CARGO_EOF'
        [target.aarch64-linux-android]
        ar = "AR_PLACEHOLDER"
        linker = "AARCH64_LINKER_PLACEHOLDER"

        [target.armv7-linux-androideabi]
        ar = "AR_PLACEHOLDER"
        linker = "ARMV7_LINKER_PLACEHOLDER"

        [target.x86_64-linux-android]
        ar = "AR_PLACEHOLDER"
        linker = "X86_64_LINKER_PLACEHOLDER"

        [target.i686-linux-android]
        ar = "AR_PLACEHOLDER"
        linker = "I686_LINKER_PLACEHOLDER"
        CARGO_EOF

        # Replace placeholders with actual paths
        sed -i "s|AR_PLACEHOLDER|$NDK_TOOLCHAIN/llvm-ar|g" ~/.cargo/config.toml
        sed -i "s|AARCH64_LINKER_PLACEHOLDER|$AARCH64_LINKER|g" ~/.cargo/config.toml
        sed -i "s|ARMV7_LINKER_PLACEHOLDER|$ARMV7_LINKER|g" ~/.cargo/config.toml
        sed -i "s|X86_64_LINKER_PLACEHOLDER|$X86_64_LINKER|g" ~/.cargo/config.toml
        sed -i "s|I686_LINKER_PLACEHOLDER|$I686_LINKER|g" ~/.cargo/config.toml

        echo "Cargo config created:"
        cat ~/.cargo/config.toml

        # Verify all tools exist
        echo "Verifying all tools exist:"
        for tool in "$NDK_TOOLCHAIN/llvm-ar" "$AARCH64_LINKER" "$ARMV7_LINKER" "$X86_64_LINKER" "$I686_LINKER"; do
          if [ -f "$tool" ]; then
            echo "‚úÖ $tool"
          else
            echo "‚ùå $tool (not found)"
          fi
        done
      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Verify NDK Tools
      run: |
        echo "Verifying NDK tools are available..."
        echo "NDK_HOME: $NDK_HOME"
        ls -la "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" | head -10

        # Test if the linkers exist
        if [ -f "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/aarch64-linux-android21-clang" ]; then
          echo "‚úÖ ARM64 linker found"
        else
          echo "‚ùå ARM64 linker not found"
          echo "Available linkers:"
          find "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" -name "*android*clang*" | head -5
        fi
      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Install Tauri CLI
      run: |
        echo "Installing Tauri CLI (latest version)..."
        npm install -g @tauri-apps/cli@latest

        echo "Verifying Tauri CLI installation..."
        which tauri || echo "Tauri CLI not found in PATH"
        tauri --version || echo "Failed to get Tauri version"

        echo "Checking if tauri is available via npx..."
        npx tauri --version || echo "npx tauri failed"

        echo "Installing Tauri CLI locally as well..."
        npm install @tauri-apps/cli@latest

        echo "Verifying local installation..."
        npx tauri --version || echo "Local npx tauri failed"

        echo "Checking package.json scripts..."
        cat package.json | grep -A 5 -B 5 "scripts" || echo "No scripts section found"

    - name: Install dependencies
      run: npm ci

    - name: Setup Android Code Signing
      working-directory: ./client
      run: |
        echo "Setting up Android code signing for CI..."

        # Create keystore directory
        mkdir -p android/

        # Decode and save the keystore file with CI environment variables approach
        if [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ]; then
          echo "‚úÖ Android keystore found in secrets"
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > android/release.keystore

          echo "‚úÖ Android code signing configured with environment variables"
          ls -la android/release.keystore
        else
          echo "‚ö†Ô∏è  No Android keystore found in secrets - building unsigned APK"
          echo "To enable signed builds, add these secrets to your GitHub repository:"
          echo "- ANDROID_KEYSTORE_BASE64: Base64 encoded keystore file"
          echo "- ANDROID_KEYSTORE_PASSWORD: Keystore password"
          echo "- ANDROID_KEY_ALIAS: Key alias"
          echo "- ANDROID_KEY_PASSWORD: Key password"
        fi

    - name: Debug Signing Setup
      working-directory: ./client
      run: |
        echo "=== Checking CI signing setup ==="
        if [ -f "android/release.keystore" ]; then
          echo "‚úÖ Keystore file exists at android/release.keystore"
          ls -la android/release.keystore
        else
          echo "‚ùå Keystore file not found"
          ls -la android/ || echo "Android directory not found"
        fi

        echo "=== Environment variables for signing ==="
        echo "CI: $CI"
        echo "KEYSTORE_PATH: $KEYSTORE_PATH"
        echo "ANDROID_HOME: $ANDROID_HOME"
        echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"

        # Check if all required signing environment variables are set (without showing values)
        if [ -n "$KEYSTORE_PASSWORD" ]; then
          echo "‚úÖ KEYSTORE_PASSWORD is set"
        else
          echo "‚ùå KEYSTORE_PASSWORD not set"
        fi

        if [ -n "$KEY_ALIAS" ]; then
          echo "‚úÖ KEY_ALIAS is set"
        else
          echo "‚ùå KEY_ALIAS not set"
        fi

        if [ -n "$KEY_PASSWORD" ]; then
          echo "‚úÖ KEY_PASSWORD is set"
        else
          echo "‚ùå KEY_PASSWORD not set"
        fi
      env:
        # Android signing environment variables for debugging
        CI: true
        KEYSTORE_PATH: android/release.keystore
        KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

    - name: Build client
      run: npm run build:client
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}

    - name: Initialize Android project
      working-directory: ./client
      run: |
        echo "Initializing Tauri Android project..."
        echo "Environment variables:"
        echo "ANDROID_HOME: $ANDROID_HOME"
        echo "NDK_HOME: $NDK_HOME"
        echo "JAVA_HOME: $JAVA_HOME"

        echo "Available npm scripts in client directory:"
        npm run | grep tauri || echo "No tauri scripts found"

        echo "Checking Tauri CLI availability:"
        npx tauri --version || echo "npx tauri not available"

        # Try different approaches to run tauri android init
        echo "Attempting to initialize Android project..."

        # Try npm scripts first, then npx
        if npm run tauri:android:init -- --ci; then
          echo "‚úÖ Android project initialized with npm script"
        elif npx tauri android init --ci; then
          echo "‚úÖ Android project initialized with npx tauri"
        else
          echo "‚ùå All initialization methods failed"
          echo "Checking Tauri CLI installation..."

          # Debug information
          npm list @tauri-apps/cli || echo "Local @tauri-apps/cli not found"
          ls -la node_modules/.bin/ | grep tauri || echo "No tauri in node_modules/.bin"
          echo "Checking root node_modules:"
          ls -la ../node_modules/.bin/ | grep tauri || echo "No tauri in root node_modules/.bin"
        fi

        echo "Checking for generated project..."
        find . -name "gen" -type d 2>/dev/null || echo "No gen directory found"
        find . -name "android" -type d 2>/dev/null || echo "No android directory found"

        # Check if Android project was created
        if [ -d "src-tauri/gen/android" ]; then
          echo "‚úÖ Android project created successfully"
          ls -la src-tauri/gen/
        else
          echo "‚ùå Android project directory not found, trying alternative paths..."
          find src-tauri -type d -name "*android*" 2>/dev/null || echo "No Android directories found"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}
        JAVA_HOME: ${{ env.JAVA_HOME }}

    - name: Debug Android Project Generation (Compare with Local)
      working-directory: ./client
      run: |
        echo "=== DEBUGGING: Android Project Generation for Local vs CI Comparison ==="

        if [ -d "src-tauri/gen/android" ]; then
          echo "üîç Analyzing generated Android project..."

          echo "=== 1. Tauri CLI Version Info ==="
          npx tauri --version || echo "npx tauri version failed"
          cargo tauri --version || echo "cargo tauri version failed"

          echo "=== 2. Android Project Structure ==="
          find src-tauri/gen/android -type f -name "*.xml" -o -name "*.gradle*" -o -name "*.kt" | head -20

          echo "=== 3. Android Manifest Contents (COMPLETE) ==="
          if [ -f "src-tauri/gen/android/app/src/main/AndroidManifest.xml" ]; then
            echo "--- COMPLETE AndroidManifest.xml ---"
            cat src-tauri/gen/android/app/src/main/AndroidManifest.xml
            echo "--- END AndroidManifest.xml ---"
          else
            echo "‚ùå AndroidManifest.xml not found"
            find src-tauri/gen/android -name "AndroidManifest.xml" 2>/dev/null || echo "No manifest files found"
          fi

          echo "=== 4. Android Themes (CRITICAL FOR STATUS BAR) ==="
          echo "--- themes.xml ---"
          cat src-tauri/gen/android/app/src/main/res/values/themes.xml 2>/dev/null || echo "No themes.xml found"
          echo "--- themes.xml (night) ---"
          cat src-tauri/gen/android/app/src/main/res/values-night/themes.xml 2>/dev/null || echo "No night themes.xml found"
          echo "--- colors.xml ---"
          cat src-tauri/gen/android/app/src/main/res/values/colors.xml 2>/dev/null || echo "No colors.xml found"
          echo "--- strings.xml ---"
          cat src-tauri/gen/android/app/src/main/res/values/strings.xml 2>/dev/null || echo "No strings.xml found"

          echo "=== 5. Build Configuration Files ==="
          if [ -f "src-tauri/gen/android/app/build.gradle.kts" ]; then
            echo "--- app/build.gradle.kts (first 50 lines) ---"
            head -50 src-tauri/gen/android/app/build.gradle.kts
          fi

          if [ -f "src-tauri/gen/android/build.gradle.kts" ]; then
            echo "--- root build.gradle.kts ---"
            cat src-tauri/gen/android/build.gradle.kts
          fi

          echo "=== 6. Generated App Configuration ==="
          find src-tauri/gen/android -name "*.properties" -exec echo "--- {} ---" \; -exec cat {} \; 2>/dev/null || echo "No properties files found"

          echo "=== 7. Android Resources ==="
          echo "Generated drawable resources:"
          find src-tauri/gen/android -path "*/res/drawable*" -name "*.png" -o -name "*.xml" | head -10 || echo "No drawable resources found"

          echo "Generated layout resources:"
          find src-tauri/gen/android -path "*/res/layout*" -name "*.xml" | head -5 || echo "No layout resources found"

          echo "=== 8. Tauri Configuration Used ==="
          echo "--- tauri.conf.json ---"
          cat src-tauri/tauri.conf.json | head -50

          echo "=== 9. Environment Variables During Generation ==="
          env | grep -E "(ANDROID|TAURI|JAVA|SDK)" | sort

        else
          echo "‚ùå No Android project found - initialization may have failed"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Generate Android App Icons
      working-directory: ./client
      run: |
        echo "üé® Generating Android app icons AFTER project initialization..."

        # Verify Android project exists before generating icons
        if [ ! -d "src-tauri/gen/android" ]; then
          echo "‚ùå Android project not found, cannot generate icons"
          exit 1
        fi

        # Check if the icon file exists
        ICON_FILE="src-tauri/icons/be-out_icon_512x512.png"
        if [ -f "$ICON_FILE" ]; then
          echo "‚úÖ Found icon file: $ICON_FILE"
          ls -la "$ICON_FILE"

          echo "=== Icons BEFORE generation ==="
          find src-tauri/icons -name "*.png" -o -name "*.ico" | head -10

          echo "Generating icons using Tauri CLI..."
          if npx tauri icon "$ICON_FILE" --verbose; then
            echo "‚úÖ Icons generated successfully"

            echo "=== Icons AFTER generation ==="
            find src-tauri/icons -name "*.png" -o -name "*.ico" | head -15

            # Verify Android-specific icon files were created
            echo "=== Android-specific icons ==="
            find src-tauri/icons -name "android-icon-*.png" -o -name "*android*" | head -10

            # Also check if icons were copied to the Android project
            echo "=== Android project icon resources ==="
            find src-tauri/gen/android -path "*/res/drawable*" -name "*.png" | head -10 || echo "No drawable icons found in Android project"
            find src-tauri/gen/android -path "*/res/mipmap*" -name "*.png" | head -10 || echo "No mipmap icons found in Android project"
          else
            echo "‚ùå Failed to generate icons with npx tauri"
            echo "Trying alternative methods..."

            # Try with cargo tauri
            if command -v cargo >/dev/null 2>&1; then
              echo "Trying with cargo tauri icon..."
              cargo tauri icon "$ICON_FILE" --verbose || echo "cargo tauri icon also failed"
            fi

            # Try with global tauri command
            if command -v tauri >/dev/null 2>&1; then
              echo "Trying with global tauri command..."
              tauri icon "$ICON_FILE" --verbose || echo "global tauri icon also failed"
            fi
          fi
        else
          echo "‚ùå Icon file not found: $ICON_FILE"
          echo "Available files in src-tauri/icons/:"
          ls -la src-tauri/icons/ || echo "Icons directory not found"

          # Try to find any PNG files that could be used as icons
          echo "Looking for alternative icon files..."
          find src-tauri -name "*.png" | head -5
          exit 1
        fi

    - name: Fix Android Themes for Status Bar
      working-directory: ./client
      run: |
        echo "üîß Fixing Android themes to prevent status bar overlap..."

        # Ensure the generated Android project exists
        if [ -d "src-tauri/gen/android" ]; then
          # Fix the main themes.xml file
          if [ -f "src-tauri/gen/android/app/src/main/res/values/themes.xml" ]; then
            echo "üìù Patching main themes.xml..."
            cat > src-tauri/gen/android/app/src/main/res/values/themes.xml << 'XMLEOF1'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        XMLEOF1
          else
            echo "‚ùå Main themes.xml not found, creating it..."
            mkdir -p src-tauri/gen/android/app/src/main/res/values
            cat > src-tauri/gen/android/app/src/main/res/values/themes.xml << 'XMLEOF2'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        XMLEOF2
          fi

          # Fix the night themes.xml file if it exists
          if [ -f "src-tauri/gen/android/app/src/main/res/values-night/themes.xml" ]; then
            echo "üìù Patching night themes.xml..."
            cat > src-tauri/gen/android/app/src/main/res/values-night/themes.xml << 'XMLEOF3'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        XMLEOF3
          else
            echo "üåô Night themes.xml not found, creating it..."
            mkdir -p src-tauri/gen/android/app/src/main/res/values-night
            cat > src-tauri/gen/android/app/src/main/res/values-night/themes.xml << 'XMLEOF4'
        <resources xmlns:tools="http://schemas.android.com/tools">
            <!-- Base application theme. -->
            <style name="Theme.app" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                <!-- Use standard Material Design colors -->
                <item name="colorPrimary">@android:color/holo_blue_bright</item>
                <item name="colorPrimaryDark">@android:color/holo_blue_dark</item>
                <item name="colorAccent">@android:color/holo_blue_light</item>
            </style>
        </resources>
        XMLEOF4
          fi

          echo "‚úÖ Android themes patched successfully!"
          echo "üìã Verifying theme files after patching:"
          find src-tauri/gen/android -name "themes.xml" -exec echo "--- {} ---" \; -exec cat {} \;
        else
          echo "‚ùå No Android project found to patch"
        fi

    - name: Patch Android Build for Signing
      working-directory: ./client
      run: |
        echo "=== Patching Android app build.gradle.kts for signing ==="

        APP_BUILD_FILE="src-tauri/gen/android/app/build.gradle.kts"

        if [ -f "$APP_BUILD_FILE" ]; then
          echo "‚úÖ Found app build file: $APP_BUILD_FILE"

          # Create a backup
          cp "$APP_BUILD_FILE" "$APP_BUILD_FILE.backup"

          # Check if signingConfigs already exists (to avoid double-patching)
          if grep -q "signingConfigs" "$APP_BUILD_FILE"; then
            echo "‚ö†Ô∏è signingConfigs already exists, skipping patch"
          else
            echo "üîß Adding signing configuration to app build file..."

            # Create the signing configuration content using echo statements
            echo "" > signing_config_patch.txt
            echo "    signingConfigs {" >> signing_config_patch.txt
            echo "        if (System.getenv(\"CI\") == \"true\" && System.getenv(\"KEYSTORE_PATH\") != null) {" >> signing_config_patch.txt
            echo "            create(\"release\") {" >> signing_config_patch.txt
            echo "                storeFile = file(\"../../../../\${System.getenv(\"KEYSTORE_PATH\")}\")" >> signing_config_patch.txt
            echo "                storePassword = System.getenv(\"KEYSTORE_PASSWORD\")" >> signing_config_patch.txt
            echo "                keyAlias = System.getenv(\"KEY_ALIAS\")" >> signing_config_patch.txt
            echo "                keyPassword = System.getenv(\"KEY_PASSWORD\")" >> signing_config_patch.txt
            echo "            }" >> signing_config_patch.txt
            echo "        } else {" >> signing_config_patch.txt
            echo "            // Load keystore properties from git-ignored file for local development" >> signing_config_patch.txt
            echo "            val keystoreProperties = Properties().apply {" >> signing_config_patch.txt
            echo "                val propFile = file(\"../../../../../src-tauri/keystore.properties\")" >> signing_config_patch.txt
            echo "                if (propFile.exists()) {" >> signing_config_patch.txt
            echo "                    propFile.inputStream().use { load(it) }" >> signing_config_patch.txt
            echo "                }" >> signing_config_patch.txt
            echo "            }" >> signing_config_patch.txt
            echo "" >> signing_config_patch.txt
            echo "            if (keystoreProperties.containsKey(\"keyAlias\")) {" >> signing_config_patch.txt
            echo "                create(\"release\") {" >> signing_config_patch.txt
            echo "                    storeFile = file(\"../../../../../src-tauri/\${keystoreProperties[\"storeFile\"]}\")" >> signing_config_patch.txt
            echo "                    storePassword = keystoreProperties[\"storePassword\"] as String" >> signing_config_patch.txt
            echo "                    keyAlias = keystoreProperties[\"keyAlias\"] as String" >> signing_config_patch.txt
            echo "                    keyPassword = keystoreProperties[\"keyPassword\"] as String" >> signing_config_patch.txt
            echo "                }" >> signing_config_patch.txt
            echo "            }" >> signing_config_patch.txt
            echo "        }" >> signing_config_patch.txt
            echo "    }" >> signing_config_patch.txt

            # Insert the signing configuration after the defaultConfig block
            # Use a simpler approach with awk to avoid sed delimiter issues
            awk '
            /defaultConfig \{/ { in_config = 1 }
            in_config && /^\s*\}/ && !inserted {
                print $0
                while ((getline line < "signing_config_patch.txt") > 0) {
                    print line
                }
                close("signing_config_patch.txt")
                inserted = 1
                next
            }
            { print }
            ' "$APP_BUILD_FILE" > "$APP_BUILD_FILE.tmp" && mv "$APP_BUILD_FILE.tmp" "$APP_BUILD_FILE"

            # Add signingConfig to the release buildType using a different approach
            # First create a temporary patch file for the signing config line
            echo "            signingConfig = signingConfigs.findByName(\"release\")" > buildtype_patch.txt

            # Insert the signingConfig line before the closing brace of the release buildType
            awk '
            /getByName\("release"\) \{/ { in_release = 1 }
            in_release && /^\s*\}/ && !inserted {
                while ((getline line < "buildtype_patch.txt") > 0) {
                    print line
                }
                close("buildtype_patch.txt")
                print $0
                inserted = 1
                next
            }
            { print }
            ' "$APP_BUILD_FILE" > "$APP_BUILD_FILE.tmp" && mv "$APP_BUILD_FILE.tmp" "$APP_BUILD_FILE"

            # Clean up the temporary file
            rm buildtype_patch.txt

            # Add validation block at the end, before rust block
            echo "" >> "$APP_BUILD_FILE"
            echo "afterEvaluate {" >> "$APP_BUILD_FILE"
            echo "    if (System.getenv(\"CI\") == \"true\") {" >> "$APP_BUILD_FILE"
            echo "        val signingConfig = android.signingConfigs.findByName(\"release\")" >> "$APP_BUILD_FILE"
            echo "        // Fail the build if signingConfig is missing or any value is missing" >> "$APP_BUILD_FILE"
            echo "        if (signingConfig == null ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.storeFile == null ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.storePassword.isNullOrBlank() ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.keyAlias.isNullOrBlank() ||" >> "$APP_BUILD_FILE"
            echo "            signingConfig.keyPassword.isNullOrBlank()" >> "$APP_BUILD_FILE"
            echo "        ) {" >> "$APP_BUILD_FILE"
            echo "            throw org.gradle.api.GradleException(\"Signing config for release build is missing or incomplete. Please check your environment variables.\")" >> "$APP_BUILD_FILE"
            echo "        }" >> "$APP_BUILD_FILE"
            echo "    }" >> "$APP_BUILD_FILE"
            echo "}" >> "$APP_BUILD_FILE"

            echo "‚úÖ Successfully patched app build file for signing"

            # Show the changes
            echo "=== Patched build file content (first 100 lines) ==="
            head -100 "$APP_BUILD_FILE"

            # Clean up
            rm signing_config_patch.txt
          fi
        else
          echo "‚ùå App build file not found: $APP_BUILD_FILE"
          echo "Available files in Android project:"
          find src-tauri/gen/android -name "*.gradle*" 2>/dev/null || echo "No gradle files found"
        fi

    - name: Debug Gradle Build Process Before Tauri
      working-directory: ./client
      run: |
        echo "=== Manual Gradle Build Debug ==="

        if [ -d "src-tauri/gen/android" ]; then
          cd src-tauri/gen/android

          echo "=== Gradle Project Structure ==="
          ls -la

          echo "=== Gradle Wrapper Permissions ==="
          ls -la gradlew
          chmod +x gradlew

          echo "=== Gradle Version ==="
          ./gradlew --version

          echo "=== Android Project Tasks ==="
          ./gradlew tasks --all | head -50

          echo "=== Checking Build File Contents ==="
          echo "--- app/build.gradle.kts (first 50 lines) ---"
          head -50 app/build.gradle.kts || echo "No app build file found"

          echo "=== Trying Basic Gradle Build ==="
          if ./gradlew build --info --stacktrace 2>&1 | tee manual_gradle_build.log; then
            echo "‚úÖ Manual Gradle build succeeded"
          else
            echo "‚ùå Manual Gradle build failed"
            echo "=== Last 50 lines of Gradle build log ==="
            tail -50 manual_gradle_build.log

            echo "=== Looking for specific error patterns ==="
            grep -i "error\|exception\|failed\|could not" manual_gradle_build.log | tail -20

            echo "=== Checking for signing-related errors ==="
            grep -i "sign\|keystore\|alias\|password" manual_gradle_build.log | tail -10
          fi
        else
          echo "‚ùå Android project directory not found"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}
        JAVA_HOME: ${{ env.JAVA_HOME }}
        # Android signing environment variables
        CI: true
        KEYSTORE_PATH: android/release.keystore
        KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

    - name: Debug Rust Build Environment
      run: |
        echo "=== Rust Build Environment Debug ==="
        echo "Rust version:"
        rustc --version
        echo "Cargo version:"
        cargo --version
        echo "Installed targets:"
        rustup target list --installed
        echo "Cargo config:"
        cat ~/.cargo/config.toml || echo "No Cargo config found"
        echo "NDK tools verification:"
        ls -la "$NDK_HOME/toolchains/llvm/prebuilt/linux-x86_64/bin/" | grep -E "(aarch64|armv7|x86_64|i686).*android.*clang" || echo "No Android clang tools found"
        echo "Environment variables:"
        env | grep -E "(ANDROID|NDK|JAVA|CARGO|RUST)" | sort
      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Test Rust Cross-Compilation
      run: |
        echo "=== Testing Rust Cross-Compilation for Android ==="
        echo "Testing if we can compile a simple Rust program for Android targets..."

        # Create a simple test Rust program
        mkdir -p /tmp/rust_test
        cd /tmp/rust_test

        # Create Cargo.toml
        cat > Cargo.toml << 'CARGO_TOML_EOF'
        [package]
        name = "test_android"
        version = "0.1.0"
        edition = "2021"

        [[bin]]
        name = "test_android"
        path = "src/main.rs"
        CARGO_TOML_EOF

        # Create main.rs
        mkdir -p src
        cat > src/main.rs << 'MAIN_RS_EOF'
        fn main() {
            println!("Hello Android!");
        }
        MAIN_RS_EOF

        echo "Created test project, testing compilation for each Android target:"

        # Test aarch64-linux-android
        echo "Testing aarch64-linux-android..."
        if cargo build --target aarch64-linux-android --verbose 2>&1; then
          echo "‚úÖ aarch64-linux-android compilation successful"
        else
          echo "‚ùå Failed to compile for aarch64-linux-android"
          echo "Checking linker configuration..."
          cat ~/.cargo/config.toml | grep -A 2 aarch64-linux-android || echo "No config found"
        fi

        # Test armv7-linux-androideabi
        echo "Testing armv7-linux-androideabi..."
        if cargo build --target armv7-linux-androideabi --verbose 2>&1; then
          echo "‚úÖ armv7-linux-androideabi compilation successful"
        else
          echo "‚ùå Failed to compile for armv7-linux-androideabi"
          echo "Checking linker configuration..."
          cat ~/.cargo/config.toml | grep -A 2 armv7-linux-androideabi || echo "No config found"
        fi

      env:
        NDK_HOME: ${{ env.NDK_HOME }}

    - name: Debug Gradle Build Process
      working-directory: ./client
      run: |
        echo "=== Debugging Gradle Build Process ==="
        cd src-tauri/gen/android

        echo "Gradle wrapper version:"
        ./gradlew --version

        echo "Android project tasks:"
        ./gradlew tasks --all | grep -E "(rust|Build)" || echo "No rust-related tasks found"

        echo "Attempting to run rustBuildArm64Release task manually with more details:"
        if ./gradlew :app:rustBuildArm64Release --info --stacktrace 2>&1 | tee gradle_rust_debug.log; then
          echo "‚úÖ Manual Gradle task succeeded"
        else
          echo "‚ùå Manual Gradle task failed"
          echo "=== Gradle Error Analysis ==="
          tail -50 gradle_rust_debug.log
          echo "=== Looking for Node.js errors ==="
          grep -i "node\|javascript\|process.*finished.*non-zero" gradle_rust_debug.log || echo "No Node.js specific errors found"
        fi

      env:
        NDK_HOME: ${{ env.NDK_HOME }}
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        JAVA_HOME: ${{ env.JAVA_HOME }}

    - name: Verify Icons Before Android Build
      working-directory: ./client
      run: |
        echo "üîç Final verification of icons before Android build..."

        # Check if icons are in place
        echo "=== Current icon files ==="
        find src-tauri/icons -name "*.png" -o -name "*.ico" | head -15

        # Check for custom icon
        if [ -f "src-tauri/icons/be-out_icon_512x512.png" ]; then
          echo "‚úÖ Custom icon source file exists"
        else
          echo "‚ùå Custom icon source file missing!"
        fi

        # Check for generated Android icons
        echo "=== Android-specific generated icons ==="
        find src-tauri/icons -name "android-icon-*.png" | head -10

        # If Android project exists, check for icons there too
        if [ -d "src-tauri/gen/android" ]; then
          echo "=== Icons in Android project ==="
          find src-tauri/gen/android -path "*/res/drawable*" -name "*.png" | head -5 || echo "No drawable icons"
          find src-tauri/gen/android -path "*/res/mipmap*" -name "*.png" | head -5 || echo "No mipmap icons"
        fi

    - name: Build Android APK
      working-directory: ./client
      run: |
        echo "Building Android APK..."
        echo "Checking Android project directory..."

        # Find Android project directory
        ANDROID_PROJECT_DIR=""
        if [ -d "src-tauri/gen/android" ]; then
          ANDROID_PROJECT_DIR="src-tauri/gen/android"
          echo "‚úÖ Found Android project at: $ANDROID_PROJECT_DIR"
        else
          echo "üîç Searching for Android project directory..."
          ANDROID_PROJECT_DIR=$(find src-tauri -type d -name "*android*" 2>/dev/null | head -1)
          if [ -n "$ANDROID_PROJECT_DIR" ]; then
            echo "‚úÖ Found Android project at: $ANDROID_PROJECT_DIR"
          else
            echo "‚ùå No Android project found, re-initializing..."
            npx tauri android init --ci
            if [ -d "src-tauri/gen/android" ]; then
              ANDROID_PROJECT_DIR="src-tauri/gen/android"
              echo "‚úÖ Re-initialization successful: $ANDROID_PROJECT_DIR"
            else
              echo "‚ùå Re-initialization failed"
              exit 1
            fi
          fi
        fi

        echo "Android project directory contents:"
        ls -la "$ANDROID_PROJECT_DIR"/ 2>/dev/null || echo "Cannot list directory contents"

        echo "Starting Android build..."
        echo "Environment check before build:"
        echo "ANDROID_HOME: $ANDROID_HOME"
        echo "ANDROID_SDK_ROOT: $ANDROID_SDK_ROOT"
        echo "NDK_HOME: $NDK_HOME"
        echo "JAVA_HOME: $JAVA_HOME"
        echo "CI: $CI"
        echo "KEYSTORE_PATH: $KEYSTORE_PATH"

        # Set additional environment variables that Tauri might need
        export ANDROID_NDK_ROOT="$NDK_HOME"
        export ANDROID_NDK_HOME="$NDK_HOME"

        echo "Additional environment variables set:"
        echo "ANDROID_NDK_ROOT: $ANDROID_NDK_ROOT"
        echo "ANDROID_NDK_HOME: $ANDROID_NDK_HOME"

        # Try building with more verbose output and error handling
        echo "Building for Android with detailed logging..."
        set -x  # Enable command tracing

        # First, let's try a simple build to see what happens
        echo "=== Starting Tauri Android Build ==="

        # Use the npm script that's defined in package.json
        echo "=== Attempting Tauri Build with Enhanced Error Reporting ==="

        # Run with maximum verbosity and capture all output
        if npm run tauri:android:build -- --verbose 2>&1 | tee android_build.log; then
          BUILD_EXIT_CODE=0
          echo "‚úÖ Build succeeded with npm run tauri:android:build"
        elif npm run tauri android build -- --verbose 2>&1 | tee android_build.log; then
          BUILD_EXIT_CODE=0
          echo "‚úÖ Build succeeded with npm run tauri android build"
        elif npx tauri android build --verbose 2>&1 | tee android_build.log; then
          BUILD_EXIT_CODE=0
          echo "‚úÖ Build succeeded with npx tauri command"
        else
          BUILD_EXIT_CODE=1
          echo "‚ùå All build methods failed"

          # Immediately analyze the Gradle failure
          echo "=== GRADLE BUILD FAILURE ANALYSIS ==="

          if [ -d "src-tauri/gen/android" ]; then
            cd src-tauri/gen/android

            echo "=== Running Gradle with maximum verbosity ==="
            ./gradlew assembleRelease --info --stacktrace --debug 2>&1 | tee detailed_gradle.log

            echo "=== Gradle Build File Verification ==="
            echo "--- app/build.gradle.kts content around signingConfigs ---"
            grep -A 10 -B 5 "signingConfigs\|signingConfig" app/build.gradle.kts || echo "No signing config found in build file"

            echo "=== Environment Variables in Gradle Context ==="
            ./gradlew :app:tasks --info 2>&1 | grep -i "environment\|CI\|KEYSTORE\|KEY_" || echo "No environment variable info found"

            echo "=== Last 100 lines of detailed Gradle log ==="
            tail -100 detailed_gradle.log

            cd ../../..
          fi
        fi

        echo "=== Build completed with exit code: $BUILD_EXIT_CODE ==="

        if [ $BUILD_EXIT_CODE -eq 0 ]; then
          echo "‚úÖ Build succeeded! Looking for APK files..."
          find . -name "*.apk" -type f 2>/dev/null || echo "No APK files found despite successful build"
        else
          echo "‚ùå Build failed with exit code $BUILD_EXIT_CODE"
          echo "=== BUILD FAILED - Analyzing logs ==="
          echo "Last 50 lines of build log:"
          tail -50 android_build.log
          echo "=== Checking for common error patterns ==="
          grep -i "error\|failed\|exception" android_build.log | tail -10
          echo "=== Checking Rust compilation logs ==="
          find . -name "*.log" -type f -exec echo "=== {} ===" \; -exec tail -20 {} \; 2>/dev/null || echo "No additional log files found"

          # Don't exit immediately - let's still try to find any partial artifacts
          echo "=== Checking for partial build artifacts ==="
          find . -name "*.so" -o -name "*.a" -o -name "*.apk" -o -name "*.aab" 2>/dev/null | head -10 || echo "No build artifacts found"
        fi
      env:
        ANDROID_HOME: ${{ env.ANDROID_SDK_ROOT }}
        NDK_HOME: ${{ env.NDK_HOME }}
        JAVA_HOME: ${{ env.JAVA_HOME }}
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}
        # Android signing environment variables (CI mode)
        CI: true
        KEYSTORE_PATH: android/release.keystore
        KEYSTORE_PASSWORD: ${{ secrets.ANDROID_KEYSTORE_PASSWORD }}
        KEY_ALIAS: ${{ secrets.ANDROID_KEY_ALIAS }}
        KEY_PASSWORD: ${{ secrets.ANDROID_KEY_PASSWORD }}

    - name: Find and Upload APK
      working-directory: ./client
      run: |
        echo "=== Searching for APK files ==="
        echo "Looking for APK files in the workspace..."
        find . -name "*.apk" -type f 2>/dev/null | head -10 || echo "No APK files found"

        echo "Checking standard Android build directories:"
        find . -path "*/build/outputs/apk*" -type d 2>/dev/null || echo "No standard APK output directories found"
        find . -path "*/target/*/release*" -type d 2>/dev/null || echo "No Rust target directories found"

        echo "Checking Tauri Android project structure:"
        if [ -d "src-tauri/gen/android" ]; then
          echo "Android project directory structure:"
          find src-tauri/gen/android -type f -name "*.apk" -o -name "*.aab" 2>/dev/null || echo "No APK/AAB files in android directory"

          echo "Full directory structure of Android project:"
          find src-tauri/gen/android -type d | head -20

          echo "Build outputs directory:"
          find src-tauri/gen/android -path "*/build/outputs*" -type d -exec ls -la {} \; 2>/dev/null || echo "No build outputs found"
        fi

        echo "Checking if build actually succeeded..."
        if [ -f "android_build.log" ]; then
          echo "=== Last 20 lines of build log ==="
          tail -20 android_build.log
          echo "=== Searching for APK creation messages ==="
          grep -i "apk\|assembl\|build.*success" android_build.log || echo "No APK creation messages found"
        fi

    - name: Upload APK (if found)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: android-apk
        path: |
          client/src-tauri/gen/android/app/build/outputs/apk/**/*.apk
          client/src-tauri/gen/android/**/build/outputs/apk/**/*.apk
          client/src-tauri/target/**/release/*.apk
          client/**/*.apk
        if-no-files-found: warn

  build-ios:
    name: Build iOS IPA
    runs-on: macos-15  # Use macOS 15 which has Xcode 16+
    needs: test-client
    if: true  # Enable for testing - Tauri 2.x has iOS support
    steps:
    - uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'

    - name: Setup Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: aarch64-apple-ios,x86_64-apple-ios,aarch64-apple-ios-sim

    - name: Verify Xcode Version
      run: |
        echo "=== Xcode Environment Check ==="
        xcodebuild -version
        xcrun --show-sdk-version --sdk iphoneos || echo "iPhone SDK not found"

        # Check Xcode version compatibility
        XCODE_VERSION=$(xcodebuild -version | head -1 | sed 's/Xcode //')
        echo "Detected Xcode version: $XCODE_VERSION"

        # Tauri 2.x typically requires Xcode 15.0+ for iOS builds
        if [[ $(echo "$XCODE_VERSION 15.0" | tr " " "\n" | sort -V | head -1) != "15.0" ]]; then
          echo "‚ö†Ô∏è  Warning: Xcode version may be too old for Tauri 2.x iOS builds"
          echo "   Detected: $XCODE_VERSION"
          echo "   Required: 15.0 or later"
          echo "   This may cause project format compatibility issues"
        else
          echo "‚úÖ Xcode version appears compatible"
        fi

    - name: Check iOS Frameworks and Dependencies
      working-directory: ./client
      run: |
        echo "üîç Checking iOS SDK and Framework availability..."

        # Check iOS SDK path
        IOS_SDK_PATH=$(xcrun --show-sdk-path --sdk iphoneos)
        echo "iOS SDK Path: $IOS_SDK_PATH"

        # Check required frameworks for GoogleSignIn
        REQUIRED_FRAMEWORKS=(
          "Foundation"
          "UIKit"
          "Security"
          "SystemConfiguration"
          "AuthenticationServices"
          "LocalAuthentication"
          "SafariServices"
          "WebKit"
        )

        echo "Checking required frameworks..."
        for framework in "${REQUIRED_FRAMEWORKS[@]}"; do
          if [ -d "$IOS_SDK_PATH/System/Library/Frameworks/$framework.framework" ]; then
            echo "‚úÖ $framework.framework found"
          else
            echo "‚ùå $framework.framework MISSING"
          fi
        done

        # Check for Swift libraries
        echo "Checking Swift runtime libraries..."
        SWIFT_LIB_PATH="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift/iphoneos"
        if [ -d "$SWIFT_LIB_PATH" ]; then
          echo "‚úÖ Swift iOS libraries found at $SWIFT_LIB_PATH"
          ls -la "$SWIFT_LIB_PATH" | head -10
        else
          echo "‚ùå Swift iOS libraries not found"
        fi

        # Check Xcode version compatibility
        XCODE_VERSION=$(xcodebuild -version | head -1 | sed 's/Xcode //')
        echo "Xcode version: $XCODE_VERSION"

        # GoogleSignIn 6.2.4 requires Xcode 13.0+
        if [[ $(echo "$XCODE_VERSION 13.0" | tr " " "\n" | sort -V | head -1) != "13.0" ]]; then
          echo "‚ö†Ô∏è Warning: Xcode version may be too old for GoogleSignIn 6.2.4"
          echo "   Detected: $XCODE_VERSION"
          echo "   Required: 13.0 or later"
        else
          echo "‚úÖ Xcode version compatible with GoogleSignIn 6.2.4"
        fi

        # Test Swift compilation
        echo "Testing basic Swift compilation..."
        cat > test_swift.swift << 'SWIFTEOF'
        import Foundation
        import UIKit
        print("Swift compilation test successful")
        SWIFTEOF

        if xcrun -sdk iphoneos swiftc test_swift.swift -target arm64-apple-ios12.0 2>&1; then
          echo "‚úÖ Basic Swift compilation successful"
        else
          echo "‚ùå Basic Swift compilation failed"
        fi
        rm -f test_swift.swift test_swift

    - name: Test Google Auth Plugin Swift Package
      working-directory: ./client
      run: |
        echo "üîß Testing tauri-plugin-google-auth Swift package compilation..."
        
        # Navigate to the plugin iOS directory
        if [ ! -d "../tauri-plugin-google-auth/ios" ]; then
          echo "‚ùå iOS directory missing for Google Auth plugin!"
          echo "Expected: ../tauri-plugin-google-auth/ios"
          echo "This will cause the build to fail."
          exit 1
        fi
        
        cd ../tauri-plugin-google-auth/ios
        
        echo "üìã Package.swift contents:"
        cat Package.swift
        
        echo ""
        echo "üìã Sources directory structure:"
        find Sources -name "*.swift" -exec echo "  {}" \; 2>/dev/null || echo "  No Swift sources found"
        
        echo ""
        echo "üß™ Testing Swift package syntax and dependencies..."
        
        # Test 1: Package dump to validate Package.swift syntax
        echo "=== Test 1: Package.swift syntax validation ==="
        if swift package dump-package 2>&1; then
          echo "‚úÖ Package.swift syntax is valid"
        else
          echo "‚ùå Package.swift syntax errors detected"
        fi
        
        echo ""
        echo "=== Test 2: Dependency resolution ==="
        # Test 2: Try to resolve dependencies (this will download GoogleSignIn-iOS)
        if timeout 300 swift package resolve --verbose 2>&1; then
          echo "‚úÖ Package dependencies resolved successfully"
        else
          echo "‚ùå Package dependency resolution failed"
          echo "This could be due to:"
          echo "  - Network issues downloading GoogleSignIn-iOS"
          echo "  - Version conflicts between dependencies"
          echo "  - Xcode version incompatibility with GoogleSignIn 6.2.4"
        fi
        
        echo ""
        echo "=== Test 3: Swift source file compilation ==="
        # Test 3: Try to compile individual Swift files
        for swift_file in Sources/*.swift; do
          if [ -f "$swift_file" ]; then
            echo "Testing compilation of $(basename "$swift_file")..."
            if swift -frontend -parse "$swift_file" 2>&1; then
              echo "‚úÖ $(basename "$swift_file") syntax valid"
            else
              echo "‚ùå $(basename "$swift_file") has syntax errors"
            fi
          fi
        done
        
        echo ""
        echo "=== Test 4: Direct Swift package build attempt ==="
        # Test 4: Try to build the package directly (this is what swift-rs will do)
        if timeout 600 swift build --verbose 2>&1 | tee ../swift_package_build.log; then
          echo "‚úÖ Swift package built successfully"
          echo "This means the issue is likely in swift-rs integration, not the Swift package itself"
        else
          echo "‚ùå Swift package build failed"
          echo "This is the root cause of the tauri-plugin build failure"
          echo ""
          echo "Build log analysis:"
          echo "=================="
          tail -50 ../swift_package_build.log
          echo ""
          echo "Error patterns:"
          grep -A 5 -B 5 "error:" ../swift_package_build.log | tail -20 || echo "No specific error patterns found"
        fi
        
        cd ../../client

    - name: Install Apple Certificates and Provisioning Profiles
      run: |
        echo "üîê Setting up iOS code signing..."

        # Check if we have the required secrets for code signing
        if [ -z "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
          echo "‚ö†Ô∏è  APPLE_DEVELOPMENT_TEAM secret not found"
          echo "   Code signing will be skipped. The build may fail at signing step."
          echo "   See docs/IOS_CODE_SIGNING_SETUP.md for complete setup instructions."
          export SKIP_CODESIGN=true
        else
          echo "‚úÖ Apple Developer Team found: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export SKIP_CODESIGN=false
        fi

        if [ "$SKIP_CODESIGN" = "false" ]; then
          echo "üîë Installing certificates and provisioning profiles..."

          # Debug: Check if provisioning profile secrets are available
          echo "üîç Checking provisioning profile secrets availability..."
          if [ -n "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" ]; then
            DEV_PROFILE_LENGTH=$(echo "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" | wc -c)
            echo "‚úÖ IOS_DEVELOPMENT_PROVISIONING_PROFILE found (length: $DEV_PROFILE_LENGTH chars)"
          else
            echo "‚ùå IOS_DEVELOPMENT_PROVISIONING_PROFILE not found"
          fi

          if [ -n "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" ]; then
            DIST_PROFILE_LENGTH=$(echo "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" | wc -c)
            echo "‚úÖ IOS_DISTRIBUTION_PROVISIONING_PROFILE found (length: $DIST_PROFILE_LENGTH chars)"
          else
            echo "‚ùå IOS_DISTRIBUTION_PROVISIONING_PROFILE not found"
          fi

          # Create temporary keychain
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> $GITHUB_ENV

          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -t 3600 -u build.keychain

          # Install development certificate if available
          if [ -n "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" ]; then
            echo "üì± Installing development certificate..."

            # Debug: Check secret length and first few characters
            SECRET_LENGTH=$(echo "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" | wc -c)
            SECRET_START=$(echo "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" | head -c 50)
            echo "   Secret length: $SECRET_LENGTH characters"
            echo "   Secret starts with: ${SECRET_START}..."

            # Decode certificate
            echo "${{ secrets.APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64 }}" | base64 --decode > development_certificate.p12

            # Check decoded file
            if [ -f "development_certificate.p12" ]; then
              DECODED_SIZE=$(ls -l development_certificate.p12 | awk '{print $5}')
              echo "   Decoded P12 size: $DECODED_SIZE bytes"

              # Check if file is actually a P12
              file development_certificate.p12 || echo "   Cannot determine file type"
            else
              echo "   ‚ùå Failed to create decoded P12 file"
              exit 1
            fi

            # Test different password approaches
            echo "   Testing password approaches..."

            # Method 1: Direct secret reference
            echo "   Method 1: Direct secret reference"
            if security import development_certificate.p12 -k build.keychain -P "${{ secrets.APPLE_CERTIFICATE_PASSWORD }}" -T /usr/bin/codesign 2>&1; then
              echo "   ‚úÖ Method 1 SUCCESS"
              IMPORT_SUCCESS=true
            else
              echo "   ‚ùå Method 1 FAILED"

              # Method 2: Environment variable
              echo "   Method 2: Environment variable"
              CERT_PASSWORD="${{ secrets.APPLE_CERTIFICATE_PASSWORD }}"
              if security import development_certificate.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign 2>&1; then
                echo "   ‚úÖ Method 2 SUCCESS"
                IMPORT_SUCCESS=true
              else
                echo "   ‚ùå Method 2 FAILED"

                # Method 3: Quoted password
                echo "   Method 3: Quoted password"
                if security import development_certificate.p12 -k build.keychain -P '${{ secrets.APPLE_CERTIFICATE_PASSWORD }}' -T /usr/bin/codesign 2>&1; then
                  echo "   ‚úÖ Method 3 SUCCESS"
                  IMPORT_SUCCESS=true
                else
                  echo "   ‚ùå Method 3 FAILED"

                  # Method 4: Empty password test
                  echo "   Method 4: Empty password test"
                  if security import development_certificate.p12 -k build.keychain -P "" -T /usr/bin/codesign 2>&1; then
                    echo "   ‚úÖ Method 4 SUCCESS (empty password)"
                    IMPORT_SUCCESS=true
                  else
                    echo "   ‚ùå All methods FAILED"
                    echo "   P12 file might be corrupted or incompatible"
                    IMPORT_SUCCESS=false
                  fi
                fi
              fi
            fi

            rm development_certificate.p12

            if [ "$IMPORT_SUCCESS" = true ]; then
              echo "‚úÖ Development certificate installed successfully"
            else
              echo "‚ùå Development certificate installation failed"
              echo "   This might indicate a certificate compatibility issue"
              echo "   or that the certificates were not generated correctly"
            fi
          else
            echo "‚ö†Ô∏è  Development certificate not found in secrets"
          fi

          # Skip distribution certificate for now to focus on development certificate
          if [ -n "${{ secrets.APPLE_DISTRIBUTION_CERTIFICATE_P12_BASE64 }}" ] && [ "$IMPORT_SUCCESS" = true ]; then
            echo "üè™ Installing distribution certificate..."
            echo "${{ secrets.APPLE_DISTRIBUTION_CERTIFICATE_P12_BASE64 }}" | base64 --decode > distribution_certificate.p12

            CERT_PASSWORD="${{ secrets.APPLE_CERTIFICATE_PASSWORD }}"
            if security import distribution_certificate.p12 -k build.keychain -P "$CERT_PASSWORD" -T /usr/bin/codesign 2>&1; then
              echo "‚úÖ Distribution certificate installed"
            else
              echo "‚ö†Ô∏è  Distribution certificate installation failed (but continuing)"
            fi
            rm distribution_certificate.p12
          else
            echo "‚ö†Ô∏è  Distribution certificate not found in secrets or development failed"
          fi

          # Create provisioning profiles directory
          mkdir -p ~/Library/MobileDevice/Provisioning\ Profiles

          # Install development provisioning profile
          if [ -n "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" ]; then
            echo "üîß Installing development provisioning profile..."
            echo "${{ secrets.IOS_DEVELOPMENT_PROVISIONING_PROFILE }}" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision

            # Verify the profile was installed correctly
            if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision ]; then
              PROFILE_SIZE=$(ls -l ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision | awk '{print $5}')
              echo "‚úÖ Development provisioning profile installed (size: $PROFILE_SIZE bytes)"

          # Extract profile UUID for manual code signing
          if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision ]; then
            PROFILE_UUID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision 2>/dev/null | grep -A1 "<key>UUID</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            echo "üìã Development Profile UUID: $PROFILE_UUID"
            echo "PROFILE_UUID=$PROFILE_UUID" >> $GITHUB_ENV

            # Also extract the profile name for manual signing
            PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/development.mobileprovision 2>/dev/null | grep -A1 "<key>Name</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            echo "üìã Development Profile Name: $PROFILE_NAME"
            echo "PROFILE_NAME=$PROFILE_NAME" >> $GITHUB_ENV
          fi
            else
              echo "‚ùå Development provisioning profile file was not created"
            fi
          else
            echo "‚ö†Ô∏è  Development provisioning profile not found in secrets"
          fi

          # Install distribution provisioning profile
          if [ -n "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" ]; then
            echo "üì¶ Installing distribution provisioning profile..."
            echo "${{ secrets.IOS_DISTRIBUTION_PROVISIONING_PROFILE }}" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision

            # Verify the profile was installed correctly
            if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision ]; then
              PROFILE_SIZE=$(ls -l ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision | awk '{print $5}')
              echo "‚úÖ Distribution provisioning profile installed (size: $PROFILE_SIZE bytes)"

              # ALSO extract distribution profile UUID for IPA export
              DIST_PROFILE_UUID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision 2>/dev/null | grep -A1 "<key>UUID</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
              DIST_PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/distribution.mobileprovision 2>/dev/null | grep -A1 "<key>Name</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
              echo "üìã Distribution Profile UUID: $DIST_PROFILE_UUID"
              echo "üìã Distribution Profile Name: $DIST_PROFILE_NAME"
              echo "DIST_PROFILE_UUID=$DIST_PROFILE_UUID" >> $GITHUB_ENV
              echo "DIST_PROFILE_NAME=$DIST_PROFILE_NAME" >> $GITHUB_ENV
            else
              echo "‚ùå Distribution provisioning profile file was not created"
            fi
          else
            echo "‚ö†Ô∏è  Distribution provisioning profile not found in secrets"
          fi

          # Install ad hoc provisioning profile for test builds
          if [ -n "${{ secrets.IOS_AD_HOC_PROVISIONING_PROFILE }}" ]; then
            echo "üß™ Installing ad hoc provisioning profile..."
            echo "${{ secrets.IOS_AD_HOC_PROVISIONING_PROFILE }}" | base64 --decode > ~/Library/MobileDevice/Provisioning\ Profiles/adhoc.mobileprovision

            # Verify the profile was installed correctly
            if [ -f ~/Library/MobileDevice/Provisioning\ Profiles/adhoc.mobileprovision ]; then
              PROFILE_SIZE=$(ls -l ~/Library/MobileDevice/Provisioning\ Profiles/adhoc.mobileprovision | awk '{print $5}')
              echo "‚úÖ Ad hoc provisioning profile installed (size: $PROFILE_SIZE bytes)"

              # Extract ad hoc profile UUID for IPA export
              ADHOC_PROFILE_UUID=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/adhoc.mobileprovision 2>/dev/null | grep -A1 "<key>UUID</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
              ADHOC_PROFILE_NAME=$(security cms -D -i ~/Library/MobileDevice/Provisioning\ Profiles/adhoc.mobileprovision 2>/dev/null | grep -A1 "<key>Name</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
              echo "üìã Ad Hoc Profile UUID: $ADHOC_PROFILE_UUID"
              echo "üìã Ad Hoc Profile Name: $ADHOC_PROFILE_NAME"
              echo "ADHOC_PROFILE_UUID=$ADHOC_PROFILE_UUID" >> $GITHUB_ENV
              echo "ADHOC_PROFILE_NAME=$ADHOC_PROFILE_NAME" >> $GITHUB_ENV
            else
              echo "‚ùå Ad hoc provisioning profile file was not created"
            fi
          else
            echo "‚ö†Ô∏è  Ad hoc provisioning profile not found in secrets"
          fi

          # Set partition list to avoid permission issues
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" build.keychain

          echo "üîç Verifying code signing setup..."
          echo "Available signing identities:"
          security find-identity -v -p codesigning | head -10

          echo "Installed provisioning profiles:"
          ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No profiles directory found"

          echo "Profile details:"
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if [ -f "$profile" ]; then
              echo "--- $(basename "$profile") ---"
              # Extract more detailed information about the profile
              PROFILE_CONTENT=$(security cms -D -i "$profile" 2>/dev/null)
              echo "$PROFILE_CONTENT" | grep -E "TeamName|AppIDName|UUID|application-identifier" | head -10 || echo "Could not read profile"

              # Check if this profile matches our bundle ID
              BUNDLE_ID_MATCH=$(echo "$PROFILE_CONTENT" | grep -A1 "application-identifier" | grep "com.beout.app")
              if [ -n "$BUNDLE_ID_MATCH" ]; then
                echo "‚úÖ This profile matches bundle ID: com.beout.app"
                echo "   Bundle ID pattern: $BUNDLE_ID_MATCH"
              else
                echo "‚ùå This profile does NOT match bundle ID: com.beout.app"
                ACTUAL_BUNDLE=$(echo "$PROFILE_CONTENT" | grep -A1 "application-identifier" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
                echo "   Actual bundle ID pattern: $ACTUAL_BUNDLE"
              fi
            fi
          done

          echo "‚úÖ Code signing setup completed"
        else
          echo "‚è≠Ô∏è  Skipping code signing setup (no certificates configured)"
        fi
      env:
        APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}

    - name: Install Tauri CLI
      run: |
        echo "Installing Tauri CLI..."

        # Try to install the latest version first
        if npm install -g @tauri-apps/cli@latest; then
          TAURI_VERSION=$(npm list -g @tauri-apps/cli --depth=0 | grep @tauri-apps/cli)
          echo "‚úÖ Installed: $TAURI_VERSION"
        else
          echo "‚ùå Failed to install latest Tauri CLI"
          exit 1
        fi

        echo "Verifying Tauri CLI installation..."
        tauri --version || echo "Failed to get Tauri version "

        echo "Installing Tauri CLI locally as well..."
        npm install @tauri-apps/cli@latest

    - name: Install dependencies
      run: npm ci

    - name: Build client
      run: npm run build:client
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}

    - name: Initialize iOS project
      working-directory: ./client
      run: |
        echo "Initializing Tauri iOS project..."
        echo "Available npm scripts in client directory:"
        npm run | grep tauri || echo "No tauri scripts found"

        # Verify Google Auth plugin iOS implementation
        echo "üîß Verifying tauri-plugin-google-auth iOS configuration..."
        if [ ! -d "../tauri-plugin-google-auth/ios" ]; then
          echo "‚ùå CRITICAL: iOS directory missing for Google Auth plugin!"
          echo "The iOS implementation should be in the repository."
          echo "Please ensure the tauri-plugin-google-auth/ios directory exists with proper Package.swift and Sources."
          exit 1
        else
          echo "‚úÖ iOS directory exists for Google Auth plugin"
          echo "üìã Verifying iOS plugin structure..."
          ls -la ../tauri-plugin-google-auth/ios/

          # Verify Package.swift exists and has correct configuration
          if [ -f "../tauri-plugin-google-auth/ios/Package.swift" ]; then
            echo "‚úÖ Package.swift found"

            # Check iOS version requirement
            if grep -q "iOS(.v12)" ../tauri-plugin-google-auth/ios/Package.swift; then
              echo "‚úÖ Package.swift correctly configured for iOS 12+"
            else
              echo "‚ö†Ô∏è Package.swift may not be configured for iOS 12+"
            fi

            # Check GoogleSignIn dependency
            if grep -q "GoogleSignIn-iOS.*6.2.4" ../tauri-plugin-google-auth/ios/Package.swift; then
              echo "‚úÖ GoogleSignIn-iOS 6.2.4 dependency found"
            else
              echo "‚ö†Ô∏è GoogleSignIn-iOS 6.2.4 dependency not found"
              echo "Current Package.swift GoogleSignIn dependency:"
              grep -A 2 -B 2 "GoogleSignIn" ../tauri-plugin-google-auth/ios/Package.swift || echo "No GoogleSignIn dependency found"
            fi

            # Check required frameworks
            REQUIRED_FRAMEWORKS=("Security" "SystemConfiguration" "AuthenticationServices" "SafariServices" "LocalAuthentication")
            for framework in "${REQUIRED_FRAMEWORKS[@]}"; do
              if grep -q "$framework" ../tauri-plugin-google-auth/ios/Package.swift; then
                echo "‚úÖ $framework framework linked in Package.swift"
              else
                echo "‚ùå $framework framework NOT linked in Package.swift"
              fi
            done
          else
            echo "‚ùå CRITICAL: Package.swift missing!"
            exit 1
          fi

          # Verify Swift implementation exists and imports GoogleSignIn
          if [ -f "../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift" ]; then
            echo "‚úÖ Swift implementation file found"

            if grep -q "import GoogleSignIn" ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift; then
              echo "‚úÖ GoogleSignIn import found in Swift implementation"
            else
              echo "‚ùå GoogleSignIn import NOT found in Swift implementation"
            fi

            if grep -q "GIDSignIn.sharedInstance" ../tauri-plugin-google-auth/ios/Sources/GoogleAuthPlugin.swift; then
              echo "‚úÖ GoogleSignIn SDK usage found in Swift implementation"
            else
              echo "‚ùå GoogleSignIn SDK usage NOT found in Swift implementation"
            fi
          else
            echo "‚ùå CRITICAL: Swift implementation file missing!"
            exit 1
          fi
        fi

        # Verify the Cargo.toml configuration
        echo "üîß Verifying Google Auth plugin Cargo.toml..."
        if grep -q "links.*tauri-plugin-google-auth" ../tauri-plugin-google-auth/Cargo.toml; then
          echo "‚úÖ Cargo.toml correctly has 'links' directive for tauri-plugin builder"
        else
          echo "‚ùå WARNING: 'links' directive missing in Cargo.toml!"
          echo "This may cause plugin compilation issues."
        fi

        # Try different methods to initialize iOS project
        if npm run tauri:ios:init -- --ci; then
          echo "‚úÖ iOS project initialized with npm script"
        elif npx tauri ios init --ci; then
          echo "‚úÖ iOS project initialized with npx tauri"
        else
          echo "‚ùå All initialization methods failed"
          echo "Checking available Tauri commands..."
          npx tauri --help || echo "No help available"
        fi

        echo "Checking for generated iOS/Apple project..."
        find . -name "*ios*" -o -name "*apple*" -type d 2>/dev/null || echo "No iOS/Apple directories found"

        # Check for both ios and apple directories (Tauri uses 'apple' for iOS/macOS)
        if [ -d "src-tauri/gen/ios" ]; then
          echo "‚úÖ iOS project created successfully at src-tauri/gen/ios"
          ls -la src-tauri/gen/ios/
        elif [ -d "src-tauri/gen/apple" ]; then
          echo "‚úÖ Apple project created successfully at src-tauri/gen/apple"
          ls -la src-tauri/gen/apple/
        else
          echo "‚ùå iOS/Apple project directory not found"
          echo "Searching for alternative iOS/Apple paths..."
          find src-tauri -type d -name "*ios*" -o -name "*apple*" 2>/dev/null || echo "No iOS/Apple directories found"
        fi

    - name: Generate iOS App Icons
      working-directory: ./client
      run: |
        echo "üé® Generating iOS app icons AFTER project initialization..."

        # Verify iOS/Apple project exists before generating icons
        if [ ! -d "src-tauri/gen/ios" ] && [ ! -d "src-tauri/gen/apple" ]; then
          echo "‚ùå iOS/Apple project not found, cannot generate icons"
          echo "Available directories in src-tauri/gen/:"
          ls -la src-tauri/gen/ 2>/dev/null || echo "No gen directory found"
          exit 1
        fi

        # Check if the icon file exists
        ICON_FILE="src-tauri/icons/be-out_icon_512x512.png"
        if [ -f "$ICON_FILE" ]; then
          echo "‚úÖ Found icon file: $ICON_FILE"
          ls -la "$ICON_FILE"

          echo "=== Icons BEFORE generation ==="
          find src-tauri/icons -name "*.png" -o -name "*.ico" -o -name "*.icns" | head -15

          echo "Generating icons using Tauri CLI..."
          if npx tauri icon "$ICON_FILE" --verbose; then
            echo "‚úÖ Icons generated successfully"

            echo "=== Icons AFTER generation ==="
            find src-tauri/icons -name "*.png" -o -name "*.ico" -o -name "*.icns" | head -20

            # Verify iOS-specific icon files were created
            echo "=== iOS-specific icons ==="
            find src-tauri/icons -name "*.icns" -o -name "*ios*" | head -10
            ls -la src-tauri/icons/ios/ 2>/dev/null || echo "No iOS icons directory found"

            # Check if icons were copied to the iOS/Apple project
            echo "=== iOS/Apple project icon resources ==="
            if [ -d "src-tauri/gen/ios" ]; then
              find src-tauri/gen/ios -name "*.png" -o -name "*.icns" | head -10 || echo "No icons found in iOS project"
            fi
            if [ -d "src-tauri/gen/apple" ]; then
              find src-tauri/gen/apple -name "*.png" -o -name "*.icns" | head -10 || echo "No icons found in Apple project"
            fi
          else
            echo "‚ùå Failed to generate icons with npx tauri"
            echo "Trying alternative methods..."

            # Try with cargo tauri
            if command -v cargo >/dev/null 2>&1; then
              echo "Trying with cargo tauri icon..."
              cargo tauri icon "$ICON_FILE" --verbose || echo "cargo tauri icon also failed"
            fi

            # Try with global tauri command
            if command -v tauri >/dev/null 2>&1; then
              echo "Trying with global tauri command..."
              tauri icon "$ICON_FILE" --verbose || echo "global tauri icon also failed"
            fi
          fi
        else
          echo "‚ùå Icon file not found: $ICON_FILE"
          echo "Available files in src-tauri/icons/:"
          ls -la src-tauri/icons/ || echo "Icons directory not found"

          # Try to find any PNG files that could be used as icons
          echo "Looking for alternative icon files..."
          find src-tauri -name "*.png" | head -5
          exit 1
        fi

    - name: Verify Icons Before iOS Build
      working-directory: ./client
      run: |
        echo "üîç Final verification of icons before iOS build..."

        # Check if icons are in place
        echo "=== Current icon files ==="
        find src-tauri/icons -name "*.png" -o -name "*.ico" -o -name "*.icns" | head -15

        # Check for custom icon
        if [ -f "src-tauri/icons/be-out_icon_512x512.png" ]; then
          echo "‚úÖ Custom icon source file exists"
        else
          echo "‚ùå Custom icon source file missing!"
        fi

        # Check for generated iOS icons
        echo "=== iOS-specific generated icons ==="
        find src-tauri/icons -name "*.icns" | head -10
        ls -la src-tauri/icons/ios/ 2>/dev/null || echo "No iOS icons directory"

        # If iOS/Apple project exists, check for icons there too
        if [ -d "src-tauri/gen/ios" ]; then
          echo "=== Icons in iOS project ==="
          find src-tauri/gen/ios -name "*.png" -o -name "*.icns" | head -10 || echo "No icons in iOS project"
        fi
        if [ -d "src-tauri/gen/apple" ]; then
          echo "=== Icons in Apple project ==="
          find src-tauri/gen/apple -name "*.png" -o -name "*.icns" | head -10 || echo "No icons in Apple project"
        fi

    - name: Build iOS IPA
      working-directory: ./client
      run: |
        echo "Building iOS IPA...."
        echo "Checking iOS project directory..."

        # Find iOS project directory (Tauri uses 'apple' directory for iOS/macOS)
        IOS_PROJECT_DIR=""
        if [ -d "src-tauri/gen/ios" ]; then
          IOS_PROJECT_DIR="src-tauri/gen/ios"
          echo "‚úÖ Found iOS project at: $IOS_PROJECT_DIR"
        elif [ -d "src-tauri/gen/apple" ]; then
          IOS_PROJECT_DIR="src-tauri/gen/apple"
          echo "‚úÖ Found Apple project at: $IOS_PROJECT_DIR"
        else
          echo "üîç Searching for iOS/Apple project directory..."
          IOS_PROJECT_DIR=$(find src-tauri -type d -name "*ios*" -o -name "*apple*" 2>/dev/null | head -1)
          if [ -n "$IOS_PROJECT_DIR" ]; then
            echo "‚úÖ Found iOS/Apple project at: $IOS_PROJECT_DIR"
          else
            echo "‚ùå No iOS/Apple project found, re-initializing..."
            if npx tauri ios init --ci; then
              if [ -d "src-tauri/gen/ios" ]; then
                IOS_PROJECT_DIR="src-tauri/gen/ios"
                echo "‚úÖ Re-initialization successful: $IOS_PROJECT_DIR"
              elif [ -d "src-tauri/gen/apple" ]; then
                IOS_PROJECT_DIR="src-tauri/gen/apple"
                echo "‚úÖ Re-initialization successful: $IOS_PROJECT_DIR"
              else
                echo "‚ùå Re-initialization failed"
                exit 1
              fi
            else
              echo "‚ùå Re-initialization failed"
              exit 1
            fi
          fi
        fi

        echo "iOS/Apple project directory contents:"
        ls -la "$IOS_PROJECT_DIR"/ 2>/dev/null || echo "Cannot list directory contents"

        echo "Starting iOS build..."

        # Set up code signing environment variables
        if [ -n "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
          echo "üîê Code signing enabled with Team ID: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export APPLE_DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export APPLE_TEAM_ID="${{ secrets.APPLE_DEVELOPMENT_TEAM }}"

          # Use manual code signing with specific profile
          export CODE_SIGN_IDENTITY="iPhone Developer"
          export CODE_SIGN_STYLE="Manual"
          export DEVELOPMENT_TEAM="${{ secrets.APPLE_DEVELOPMENT_TEAM }}"
          export PRODUCT_BUNDLE_IDENTIFIER="com.beout.app"

          # Set the provisioning profile if we extracted it
          if [ -n "$PROFILE_UUID" ]; then
            export PROVISIONING_PROFILE="$PROFILE_UUID"
            echo "  Provisioning Profile UUID: $PROFILE_UUID"
          fi
          if [ -n "$PROFILE_NAME" ]; then
            export PROVISIONING_PROFILE_SPECIFIER="$PROFILE_NAME"
            echo "  Provisioning Profile Name: $PROFILE_NAME"
          fi

          echo "Code signing configuration:"
          echo "  Team ID: $APPLE_DEVELOPMENT_TEAM"
          echo "  Bundle ID: $PRODUCT_BUNDLE_IDENTIFIER"
          echo "  Identity: $CODE_SIGN_IDENTITY"
          echo "  Style: $CODE_SIGN_STYLE (Manual - using specific profile)"
        else
          echo "‚ö†Ô∏è  Warning: No code signing certificates configured."
          echo "   The build will attempt to proceed but may fail at the signing step."
          echo "   Add the required secrets to enable code signing:"
          echo "   - APPLE_DEVELOPMENT_TEAM"
          echo "   - APPLE_DEVELOPMENT_CERTIFICATE_P12_BASE64"
          echo "   - APPLE_DEVELOPMENT_PROVISIONING_PROFILE_BASE64"
          echo "   - APPLE_CERTIFICATE_PASSWORD"
          echo ""
          echo "   See docs/IOS_CODE_SIGNING_SETUP.md for complete setup instructions."
        fi

    - name: Configure iOS Xcode Project
      working-directory: ./client
      run: |
        # Try different methods to build iOS
        echo "=== Attempting Tauri iOS Build ==="

        # Debug Xcode project first
        echo "üîç Looking for Xcode project..."
        find src-tauri/gen/apple -name "*.xcodeproj" -o -name "*.xcworkspace" 2>/dev/null || echo "No Xcode project found yet"

        echo ""
        echo "üîç Checking tauri directory structure..."
        ls -la src-tauri/ || echo "No src-tauri directory"
        ls -la src-tauri/gen/ 2>/dev/null || echo "No src-tauri/gen directory"
        ls -la src-tauri/gen/apple/ 2>/dev/null || echo "No src-tauri/gen/apple directory"

        echo ""
        echo "üîç Checking for any .xcodeproj files..."
        find . -name "*.xcodeproj" -type d 2>/dev/null || echo "No .xcodeproj files found"

        # Initialize iOS project if needed
        echo ""
        echo "üöÄ Ensuring iOS project is initialized..."
        if [ ! -d "src-tauri/gen/apple" ]; then
          echo "üì± Initializing iOS project..."
          npx tauri ios init || echo "iOS init failed or already done"
        else
          echo "‚úÖ iOS project directory already exists"
        fi

        # Check if we now have an Xcode project
        echo ""
        echo "üîç Post-init: Looking for Xcode project..."
        find src-tauri/gen/apple -name "*.xcodeproj" -o -name "*.xcworkspace" 2>/dev/null || echo "Still no Xcode project found"

        # Configure Xcode project for manual code signing
        echo ""
        echo "üîß Configuring Xcode project for manual code signing..."
        if [ -f "src-tauri/gen/apple/app.xcodeproj/project.pbxproj" ]; then
          echo "üìù Updating Xcode project settings..."

          # Make a backup first
          cp src-tauri/gen/apple/app.xcodeproj/project.pbxproj src-tauri/gen/apple/app.xcodeproj/project.pbxproj.backup

          # Update the project.pbxproj file to use manual code signing
          # This is more reliable than environment variables for Xcode projects
          sed -i '' 's/CODE_SIGN_STYLE = Automatic;/CODE_SIGN_STYLE = Manual;/g' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          sed -i '' 's/CODE_SIGN_IDENTITY = "Apple Development";/CODE_SIGN_IDENTITY = "iPhone Developer";/g' src-tauri/gen/apple/app.xcodeproj/project.pbxproj

          # Add DEVELOPMENT_TEAM to all build configurations
          if [ -n "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
            # Set DEVELOPMENT_TEAM for all configurations
            sed -i '' "s/DEVELOPMENT_TEAM = \"\";/DEVELOPMENT_TEAM = \"${{ secrets.APPLE_DEVELOPMENT_TEAM }}\";/g" src-tauri/gen/apple/app.xcodeproj/project.pbxproj
            sed -i '' "s/DEVELOPMENT_TEAM = [^;]*;/DEVELOPMENT_TEAM = \"${{ secrets.APPLE_DEVELOPMENT_TEAM }}\";/g" src-tauri/gen/apple/app.xcodeproj/project.pbxproj

            # Add DEVELOPMENT_TEAM if it doesn't exist using printf
            if ! grep -q "DEVELOPMENT_TEAM" src-tauri/gen/apple/app.xcodeproj/project.pbxproj; then
              # Use printf to add the line with proper formatting
              printf '\t\t\t\tDEVELOPMENT_TEAM = "%s";\n' "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" > /tmp/dev_team_line
              sed -i '' '/buildSettings = {/r /tmp/dev_team_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
              rm /tmp/dev_team_line
            fi
          fi

          # Force CODE_SIGN_STYLE to Manual everywhere
          printf '\t\t\t\tCODE_SIGN_STYLE = Manual;\n' > /tmp/code_sign_line
          sed -i '' '/buildSettings = {/r /tmp/code_sign_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          rm /tmp/code_sign_line

          # Set explicit architecture for iOS device builds
          printf '\t\t\t\tARCHS = arm64;\n' > /tmp/archs_line
          printf '\t\t\t\tVALID_ARCHS = arm64;\n' > /tmp/valid_archs_line
          sed -i '' '/buildSettings = {/r /tmp/archs_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          sed -i '' '/buildSettings = {/r /tmp/valid_archs_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
          rm /tmp/archs_line /tmp/valid_archs_line

          # Add the provisioning profile settings
          if [ -n "$PROFILE_UUID" ]; then
            echo "üìã Adding provisioning profile settings: $PROFILE_UUID"

            # Add provisioning profile settings using printf
            printf '\t\t\t\tPROVISIONING_PROFILE = "%s";\n' "$PROFILE_UUID" > /tmp/profile_uuid_line
            printf '\t\t\t\tPROVISIONING_PROFILE_SPECIFIER = "%s";\n' "$PROFILE_NAME" > /tmp/profile_name_line

            sed -i '' '/buildSettings = {/r /tmp/profile_uuid_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj
            sed -i '' '/buildSettings = {/r /tmp/profile_name_line' src-tauri/gen/apple/app.xcodeproj/project.pbxproj

            rm /tmp/profile_uuid_line /tmp/profile_name_line
          fi

          echo "‚úÖ Xcode project configured for manual code signing"
          echo "üìã Verifying project settings..."
          grep -A 2 -B 2 "CODE_SIGN_STYLE\|PROVISIONING_PROFILE\|DEVELOPMENT_TEAM" src-tauri/gen/apple/app.xcodeproj/project.pbxproj | head -15
        else
          echo "‚ö†Ô∏è Xcode project file not found, manual configuration skipped"
        fi

    - name: Verify iOS Code Signing Setup
      working-directory: ./client
      run: |
        # Verify the final Xcode project configuration
        echo ""
        echo "üîç Final verification of Xcode project configuration..."
        if [ -f "src-tauri/gen/apple/app.xcodeproj/project.pbxproj" ]; then
          echo "üìã Code signing settings in Xcode project:"
          grep -n "CODE_SIGN_STYLE\|CODE_SIGN_IDENTITY\|PROVISIONING_PROFILE\|DEVELOPMENT_TEAM" src-tauri/gen/apple/app.xcodeproj/project.pbxproj | head -20

          echo ""
          echo "üìã Bundle identifier settings:"
          grep -n "PRODUCT_BUNDLE_IDENTIFIER" src-tauri/gen/apple/app.xcodeproj/project.pbxproj | head -5

          echo ""
          echo "üìã Detailed verification of manual code signing configuration:"
          echo "   Looking for manual CODE_SIGN_STYLE entries:"
          grep -n "CODE_SIGN_STYLE.*Manual" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   ‚ùå No manual code signing found"

          echo "   Looking for DEVELOPMENT_TEAM entries:"
          grep -n "DEVELOPMENT_TEAM.*${{ secrets.APPLE_DEVELOPMENT_TEAM }}" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   ‚ùå No development team found"

          echo "   Looking for PROVISIONING_PROFILE entries:"
          grep -n "PROVISIONING_PROFILE.*$PROFILE_UUID" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   ‚ùå No provisioning profile UUID found"

          echo "   Looking for PROVISIONING_PROFILE_SPECIFIER entries:"
          grep -n "PROVISIONING_PROFILE_SPECIFIER.*$PROFILE_NAME" src-tauri/gen/apple/app.xcodeproj/project.pbxproj || echo "   ‚ùå No provisioning profile specifier found"
        fi

        # Verify provisioning profiles one more time
        echo ""
        echo "üîç Final verification of installed provisioning profiles..."
        ls -la ~/Library/MobileDevice/Provisioning\ Profiles/ || echo "No profiles directory found"

        echo ""
        echo "üìã Detailed analysis of installed provisioning profiles:"
        for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
          if [ -f "$profile" ]; then
            echo "--- Profile: $(basename "$profile") ---"
            PROFILE_CONTENT=$(security cms -D -i "$profile" 2>/dev/null)

            # Extract key information
            PROFILE_UUID_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "<key>UUID</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            PROFILE_NAME_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "<key>Name</key>" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            BUNDLE_ID_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "application-identifier" | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')
            TEAM_ID_CHECK=$(echo "$PROFILE_CONTENT" | grep -A1 "<key>TeamIdentifier</key>" -A2 | grep "<string>" | sed 's/.*<string>\(.*\)<\/string>.*/\1/')

            echo "  UUID: $PROFILE_UUID_CHECK"
            echo "  Name: $PROFILE_NAME_CHECK"
            echo "  Bundle ID pattern: $BUNDLE_ID_CHECK"
            echo "  Team ID: $TEAM_ID_CHECK"

            # Check if this matches our expected values
            if [ "$PROFILE_UUID_CHECK" = "$PROFILE_UUID" ]; then
              echo "  ‚úÖ This profile matches our PROFILE_UUID"
            else
              echo "  ‚ùå This profile does NOT match our PROFILE_UUID ($PROFILE_UUID)"
            fi

            if [[ "$BUNDLE_ID_CHECK" == *"com.beout.app"* ]]; then
              echo "  ‚úÖ This profile matches bundle ID com.beout.app"
            else
              echo "  ‚ùå This profile does NOT match bundle ID com.beout.app"
            fi

            if [ "$TEAM_ID_CHECK" = "${{ secrets.APPLE_DEVELOPMENT_TEAM }}" ]; then
              echo "  ‚úÖ This profile matches our team ID"
            else
              echo "  ‚ùå This profile does NOT match our team ID (${{ secrets.APPLE_DEVELOPMENT_TEAM }})"
            fi
            echo ""
          fi
        done

        echo ""
        echo "üìã Available signing identities before build:"
        security find-identity -v -p codesigning | head -5

    - name: Execute iOS Build
      working-directory: ./client
      run: |
        # Configure Cargo for better CI performance
        echo ""
        echo "üîß Configuring Cargo for CI environment..."
        mkdir -p ~/.cargo
        cat > ~/.cargo/config.toml << 'EOF'
        [net]
        retry = 10

        [http]
        timeout = 300
        multiplexing = false

        [build]
        jobs = 2

        [net.git]
        fetch-with-cli = true
        EOF

        echo "‚úÖ Cargo configuration complete"
        echo "üìã Cargo config:"
        cat ~/.cargo/config.toml

        # Pre-warm Cargo cache to reduce build time
        echo ""
        echo "üî• Pre-warming Cargo cache..."
        cd src-tauri

        # Use a background process with timeout since macOS doesn't have timeout by default
        # Note: Use aarch64-apple-ios for Rust, but aarch64 for Tauri CLI
        cargo fetch --target aarch64-apple-ios &
        FETCH_PID=$!

        # Wait up to 600 seconds (10 minutes) for cargo fetch
        COUNTER=0
        while [ $COUNTER -lt 600 ]; do
          if ! kill -0 $FETCH_PID 2>/dev/null; then
            wait $FETCH_PID
            FETCH_EXIT_CODE=$?
            if [ $FETCH_EXIT_CODE -eq 0 ]; then
              echo "‚úÖ Cargo fetch completed successfully"
            else
              echo "‚ö†Ô∏è Cargo fetch completed with exit code: $FETCH_EXIT_CODE"
            fi
            break
          fi
          sleep 5
          COUNTER=$((COUNTER + 5))
        done

        # If still running after timeout, kill it
        if kill -0 $FETCH_PID 2>/dev/null; then
          echo "‚ö†Ô∏è Cargo fetch timed out after 10 minutes, terminating..."
          kill $FETCH_PID 2>/dev/null || true
          wait $FETCH_PID 2>/dev/null || true
        fi

        cd ..

        # Method 1: npm script with proper exit code handling
        echo "üöÄ Trying npm run tauri:ios:build..."

        # Set Rust/Cargo optimizations for CI
        export CARGO_NET_RETRY=10
        export CARGO_NET_TIMEOUT=300
        export CARGO_HTTP_TIMEOUT=300
        export CARGO_HTTP_MULTIPLEXING=false
        export CARGO_NET_GIT_FETCH_WITH_CLI=true

        # Set additional iOS-specific build environment variables
        export TAURI_CLI_VERBOSITY=5
        export RUST_LOG=debug
        export CARGO_INCREMENTAL=0

        # Ensure iOS SDK paths are available
        export IOS_SDK_PATH=$(xcrun --show-sdk-path --sdk iphoneos)
        echo "üìã iOS SDK Path: $IOS_SDK_PATH"

        # Test Rust compilation for iOS target before full build
        echo ""
        echo "üß™ Pre-testing Rust compilation for iOS target..."
        cd src-tauri
        if cargo check --target aarch64-apple-ios --verbose 2>&1 | tee ../rust_ios_check.log; then
          echo "‚úÖ Rust iOS target check passed"
        else
          echo "‚ùå Rust iOS target check failed - this will help diagnose the issue:"
          tail -30 ../rust_ios_check.log
          echo ""
          echo "üîç Looking for specific errors:"
          grep -A 5 -B 5 "error:" ../rust_ios_check.log | tail -15 || echo "No specific errors found"
        fi
        cd ..

        # Add timeout and memory monitoring
        echo "üìä System resources before build:"
        echo "Available memory:"
        vm_stat | grep "Pages free\|Pages active\|Pages inactive\|Pages speculative\|Pages wired"
        echo "Available disk space:"
        df -h /

        # Start a background process to monitor build progress
        (
          sleep 60
          while true; do
            echo "‚è±Ô∏è Build still running... $(date)"
            echo "üìä Current memory usage:"
            vm_stat | grep "Pages free" | head -1
            echo "üìä Build log size: $(wc -l < ios_build.log 2>/dev/null || echo 0) lines"
            sleep 300  # Log every 5 minutes
          done
        ) &
        MONITOR_PID=$!

        # Try the build without background process first to see immediate errors
        echo "üöÄ Starting iOS build (initial attempt without timeout)..."

        # Set environment variable to get full backtraces for build errors
        export CARGO_PROFILE_RELEASE_BUILD_OVERRIDE_DEBUG=true
        export RUST_BACKTRACE=full

        BUILD_SUCCESS=false
        if npm run tauri:ios:build -- --verbose --target aarch64 2>&1 | tee ios_build.log; then
          echo "‚úÖ Build succeeded with npm script"
          BUILD_SUCCESS=true
          BUILD_EXIT_CODE=0
        else
          BUILD_EXIT_CODE=$?
          echo "‚ùå npm script failed with exit code: $BUILD_EXIT_CODE"
          echo "üìã Build log content:"
          tail -50 ios_build.log

          # Look for Rust compilation errors specifically
          echo "üìã Searching for Rust compilation errors:"
          grep -A 10 -B 5 "error:" ios_build.log | tail -20 || echo "No Rust errors found in logs"

          # Look for Swift compilation errors
          echo "üìã Searching for Swift compilation errors:"
          grep -A 10 -B 5 "Swift.*error\|swift.*error\|Failed to compile swift package" ios_build.log | tail -20 || echo "No Swift errors found in log"

          # Look for GoogleSignIn specific errors
          echo "üìã Searching for GoogleSignIn specific errors:"
          grep -A 10 -B 5 "GoogleSignIn\|tauri-plugin-google-auth" ios_build.log | tail -25 || echo "No GoogleSignIn errors found"

          # Look for swift-rs compilation errors
          echo "üìã Searching for swift-rs compilation errors:"
          grep -A 10 -B 5 "swift-rs\|SwiftLinker\|Failed to compile swift package" ios_build.log | tail -20 || echo "No swift-rs errors found"
          grep -A 10 -B 5 "Swift.*error\|swift.*error" ios_build.log | tail -20 || echo "No Swift errors found in log"

          # If it fails immediately, try without arguments
          echo ""
          echo "üöÄ Trying npm run tauri:ios:build without arguments..."
          if npm run tauri:ios:build 2>&1 | tee ios_build2.log; then
            echo "‚úÖ Build succeeded with npm script (no args)"
            BUILD_SUCCESS=true
            BUILD_EXIT_CODE=0
          else
            BUILD_EXIT_CODE2=$?
            echo "‚ùå npm script also failed without args, exit code: $BUILD_EXIT_CODE2"
            echo "üìã Second build log content:"
            tail -30 ios_build2.log

            # Method 2: Try npx tauri directly with explicit target
            echo ""
            echo "üöÄ Trying npx tauri ios build with explicit target..."

            if npx tauri ios build --verbose --target aarch64 2>&1 | tee ios_build3.log; then
              echo "‚úÖ Build succeeded with npx tauri"
              BUILD_SUCCESS=true
              BUILD_EXIT_CODE=0
            else
              BUILD_EXIT_CODE3=$?
              echo "‚ùå npx tauri also failed with exit code: $BUILD_EXIT_CODE3"
              echo "üìã Third build log content:"
              tail -30 ios_build3.log

              # Method 3: Try without target specification (let Tauri decide)
              echo ""
              echo "üöÄ Trying npx tauri ios build without target..."

              if npx tauri ios build --verbose 2>&1 | tee ios_build4.log; then
                echo "‚úÖ Build succeeded with npx tauri (no target)"
                BUILD_SUCCESS=true
                BUILD_EXIT_CODE=0
              else
                BUILD_EXIT_CODE4=$?
                echo "‚ùå All build methods failed"
                echo "üìã Fourth build log content:"
                tail -30 ios_build4.log
                BUILD_SUCCESS=false
                BUILD_EXIT_CODE=$BUILD_EXIT_CODE4
              fi
            fi
          fi
        fi

        # Stop the monitoring process
        kill $MONITOR_PID 2>/dev/null || true

        # Ensure BUILD_SUCCESS is properly set
        if [ -z "$BUILD_SUCCESS" ]; then
          BUILD_SUCCESS=false
        fi

        if [ "$BUILD_SUCCESS" = true ]; then
          echo "‚úÖ Build completed! Looking for IPA files..."
          echo "=== Searching for IPA files ==="
          find . -name "*.ipa" -type f 2>/dev/null || echo "No IPA files found"

          echo "=== Searching for app bundles ==="
          find . -name "*.app" -type d 2>/dev/null | head -5 || echo "No .app bundles found"

          echo "=== Checking Xcode build directories ==="
          find . -path "*/Build/Products/*" -type f 2>/dev/null | head -10 || echo "No Xcode build products found"

        else
          echo "=== BUILD FAILED - Analyzing logs ==="
          echo "Final exit code: $BUILD_EXIT_CODE"

          # Check all log files that might exist
          for log_file in ios_build.log ios_build2.log ios_build3.log ios_build4.log; do
            if [ -f "$log_file" ]; then
              echo ""
              echo "=== Analysis of $log_file ==="
              echo "Last 50 lines of $log_file:"
              tail -50 "$log_file"
              echo ""
              echo "=== Checking for common error patterns in $log_file ==="
              grep -i "error\|failed\|exception" "$log_file" | tail -10
              echo ""
              echo "=== Checking for code signing issues in $log_file ==="
              grep -i "sign\|certificate\|team\|provision\|identity" "$log_file" | tail -10
              echo ""
              echo "=== Checking for Xcode project format issues in $log_file ==="
              grep -i "project.*format\|future.*xcode\|adjust.*project.*format" "$log_file" | tail -5
            fi
          done

          # Check for specific errors and provide guidance based on first log file
          if [ -f "ios_build.log" ] && grep -q "No signing certificate" ios_build.log; then
            echo ""
            echo "üîß CODE SIGNING ISSUE DETECTED:"
            echo "   No valid signing certificate found."
            echo "   Solutions:"
            echo "   1. Ensure certificates are properly configured in GitHub Secrets"
            echo "   2. Check that APPLE_DEVELOPMENT_TEAM is set correctly"
            echo "   3. Verify certificates haven't expired"
            echo "   4. See docs/IOS_CODE_SIGNING_SETUP.md for setup instructions"
          fi

          if [ -f "ios_build.log" ] && grep -q "tauri-plugin-google-auth.*build-script-build.*exit status: 101" ios_build.log; then
            echo ""
            echo "üîß TAURI GOOGLE AUTH PLUGIN ISSUE DETECTED:"
            echo "   The tauri-plugin-google-auth is failing to build for iOS."
            echo "   This is likely due to Swift package compilation errors."
            echo "   Solutions:"
            echo "   1. Check GoogleSignIn-iOS SDK version compatibility"
            echo "   2. Verify all required iOS frameworks are available"
            echo "   3. Check Swift compiler version compatibility"
            echo "   4. Review Package.swift configuration"
            echo ""
            echo "   Error details from build log:"
            grep -A 10 -B 5 "tauri-plugin-google-auth" ios_build.log | tail -20
            echo ""
            echo "   Swift compilation errors:"
            grep -A 5 -B 5 "Failed to compile swift package\|swift-rs.*build.rs.*Failed\|SwiftLinker::link" ios_build.log | tail -15
          fi

          if [ -f "ios_build.log" ] && grep -q "PhaseScriptExecution Build.*Rust.*Code" ios_build.log; then
            echo ""
            echo "üîß XCODE BUILD RUST CODE PHASE FAILURE DETECTED:"
            echo "   The Xcode build is failing during the 'Build Rust Code' phase."
            echo "   This indicates the Rust compilation within Xcode is failing."
            echo "   Common causes:"
            echo "   1. Rust dependencies not properly configured for iOS"
            echo "   2. Missing system libraries or frameworks"
            echo "   3. Architecture mismatch (arm64 vs x86_64)"
            echo "   4. Plugin-specific iOS compilation issues"
            echo ""
            echo "   Detailed error analysis:"
            echo "   üîç Looking for the actual Rust error (often truncated in output):"
            grep -A 20 -B 5 "Building for production" ios_build.log | tail -30 || echo "No detailed Rust build info found"
            echo ""
            echo "   üîç Looking for Swift/Xcode compilation errors:"
            grep -A 10 -B 5 "BUILD FAILED\|error:\|failed:" ios_build.log | tail -20 || echo "No specific Swift/Xcode errors found"
            echo ""
            echo "   üí° Try enabling RUST_BACKTRACE=full for more details in next run"
          fi

          if [ -f "ios_build.log" ] && grep -q "link_xcode_library\|No such file or directory.*Os.*code: 2" ios_build.log; then
            echo ""
            echo "üîß iOS LIBRARY LINKING ISSUE DETECTED:"
            echo "   A Tauri plugin is trying to link against an iOS library that doesn't exist."
            echo "   This often happens with plugins not fully configured for iOS."
            echo "   Solutions:"
            echo "   1. Check which plugin is causing the issue (likely Google Auth)"
            echo "   2. Disable problematic plugins for iOS builds"
            echo "   3. Update plugin to a version with iOS support"
            echo "   4. Add conditional compilation flags"
          fi

          if [ -f "ios_build.log" ] && grep -q "future Xcode project file format" ios_build.log; then
            echo ""
            echo "üîß XCODE PROJECT FORMAT ISSUE DETECTED:"
            echo "   The generated iOS project uses a newer format than this Xcode version supports."
            echo "   Solutions:"
            echo "   1. Update to a newer macOS runner (using macos-15)"
            echo "   2. Use an older Tauri CLI version that generates compatible projects"
            echo "   3. Update the GitHub Actions runner to use Xcode 16+"
          fi

          if [ -f "ios_build.log" ] && grep -q "Provisioning profile.*doesn't include signing certificate" ios_build.log; then
            echo ""
            echo "üîß PROVISIONING PROFILE MISMATCH:"
            echo "   The provisioning profile doesn't include the signing certificate."
            echo "   Solutions:"
            echo "   1. Regenerate the provisioning profile with the correct certificate"
            echo "   2. Ensure the certificate and profile were created with the same Apple ID"
            echo "   3. Check that the bundle ID matches exactly"
          fi

          # Check for npm script issues
          if [ -f "ios_build.log" ] && grep -q "Unknown command" ios_build.log; then
            echo ""
            echo "üîß NPM SCRIPT ISSUE DETECTED:"
            echo "   The npm script might not be properly configured."
            echo "   This could be due to package.json script definition or argument passing."
          fi

          echo ""
          echo "=== Expected Behavior ==="
          echo "iOS builds in CI typically fail at code signing without proper certificates."
          echo "If you see code signing errors, that's expected without proper setup."
          echo "Complete the setup in docs/IOS_CODE_SIGNING_SETUP.md to enable signing."

          echo ""
          echo "‚ùå BUILD FAILED - Exiting with error code"
          exit 1
        fi

    - name: Debug Swift Package Compilation Issues
      working-directory: ./client
      if: failure()
      run: |
        echo "üîç Attempting to reveal hidden Swift compilation errors..."

        # Navigate to the plugin directory
        cd ../tauri-plugin-google-auth/ios

        # Try to build the Swift package directly with maximum verbosity
        echo "=== Direct Swift Package Build Test ==="
        if swift build --verbose 2>&1 | tee swift_direct_build.log; then
          echo "‚úÖ Direct Swift build succeeded"
        else
          echo "‚ùå Direct Swift build failed"
          echo "=== Swift build errors ==="
          cat swift_direct_build.log
        fi

        # Try swift package resolve to check dependencies
        echo "=== Swift Package Dependency Resolution ==="
        if swift package resolve --verbose 2>&1 | tee swift_resolve.log; then
          echo "‚úÖ Package resolution succeeded"
        else
          echo "‚ùå Package resolution failed"
          cat swift_resolve.log
        fi

        # Check package dump
        echo "=== Swift Package Dump ==="
        swift package dump-package 2>&1 | tee swift_dump.log || echo "Package dump failed"

        # Try building with specific flags that might reveal more errors
        echo "=== Swift Build with Debug Flags ==="
        swift build \
          --verbose \
          --enable-test-discovery \
          --build-tests \
          -Xswiftc -diagnostic-style=llvm \
          -Xswiftc -Xfrontend \
          -Xswiftc -debug-diagnostic-names 2>&1 | tee swift_debug_build.log || echo "Debug build failed"

        # Check the actual Swift source files for syntax errors
        echo "=== Swift Source File Syntax Check ==="
        find Sources -name "*.swift" -exec echo "Checking {}" \; -exec swift -frontend -parse {} \; 2>&1 | tee swift_syntax_check.log || echo "Syntax check completed"

        # Try compiling individual Swift files
        echo "=== Individual Swift File Compilation ==="
        for swift_file in Sources/*.swift; do
          if [ -f "$swift_file" ]; then
            echo "Compiling $swift_file..."
            xcrun -sdk iphoneos swiftc \
              -target arm64-apple-ios12.0 \
              -parse-as-library \
              "$swift_file" 2>&1 || echo "Failed to compile $swift_file"
          fi
        done

        cd ../../client

    - name: Export IPA from Archive
      working-directory: ./client
      if: always()
      run: |
        echo "=== Attempting to Export IPA from Archive ==="

        # Find the xcarchive
        XCARCHIVE=$(find . -name "*.xcarchive" -type d 2>/dev/null | head -1)
        if [ -n "$XCARCHIVE" ]; then
          echo "‚úÖ Found xcarchive: $XCARCHIVE"

          # Create export options plist using environment variable
          TEAM_ID="${{ secrets.APPLE_DEVELOPMENT_TEAM }}"

          # Create plist file with proper escaping
          # Priority: ad hoc -> app-store (distribution) -> development
          echo '<?xml version="1.0" encoding="UTF-8"?>' > ExportOptions.plist
          echo '<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">' >> ExportOptions.plist
          echo '<plist version="1.0">' >> ExportOptions.plist
          echo '<dict>' >> ExportOptions.plist
          echo '    <key>teamID</key>' >> ExportOptions.plist
          echo "    <string>$TEAM_ID</string>" >> ExportOptions.plist
          echo '    <key>compileBitcode</key>' >> ExportOptions.plist
          echo '    <false/>' >> ExportOptions.plist
          echo '    <key>stripSwiftSymbols</key>' >> ExportOptions.plist
          echo '    <true/>' >> ExportOptions.plist
          echo '    <key>thinning</key>' >> ExportOptions.plist
          echo '    <string>&lt;none&gt;</string>' >> ExportOptions.plist
          echo '    <key>signingStyle</key>' >> ExportOptions.plist
          echo '    <string>manual</string>' >> ExportOptions.plist

          # Decide export method and provisioning profile based on availability
          if [ -n "${{ env.ADHOC_PROFILE_UUID }}" ]; then
            echo '    <key>method</key>' >> ExportOptions.plist
            echo '    <string>ad-hoc</string>' >> ExportOptions.plist
            echo '    <key>provisioningProfiles</key>' >> ExportOptions.plist
            echo '    <dict>' >> ExportOptions.plist
            echo '        <key>com.beout.app</key>' >> ExportOptions.plist
            echo "        <string>${{ env.ADHOC_PROFILE_UUID }}</string>" >> ExportOptions.plist
            echo '    </dict>' >> ExportOptions.plist
            echo "üìã Using AD HOC profile for ad-hoc export: ${{ env.ADHOC_PROFILE_UUID }}"
          elif [ -n "${{ env.DIST_PROFILE_UUID }}" ]; then
            echo '    <key>method</key>' >> ExportOptions.plist
            echo '    <string>app-store</string>' >> ExportOptions.plist
            echo '    <key>provisioningProfiles</key>' >> ExportOptions.plist
            echo '    <dict>' >> ExportOptions.plist
            echo '        <key>com.beout.app</key>' >> ExportOptions.plist
            echo "        <string>${{ env.DIST_PROFILE_UUID }}</string>" >> ExportOptions.plist
            echo '    </dict>' >> ExportOptions.plist
            echo "üìã Using DISTRIBUTION profile for app-store export: ${{ env.DIST_PROFILE_UUID }}"
          else
            echo '    <key>method</key>' >> ExportOptions.plist
            echo '    <string>development</string>' >> ExportOptions.plist
            echo "‚ö†Ô∏è No ad hoc or distribution profile found, falling back to development method"
            if [ -n "${{ env.PROFILE_UUID }}" ]; then
              echo '    <key>provisioningProfiles</key>' >> ExportOptions.plist
              echo '    <dict>' >> ExportOptions.plist
              echo '        <key>com.beout.app</key>' >> ExportOptions.plist
              echo "        <string>${{ env.PROFILE_UUID }}</string>" >> ExportOptions.plist
              echo '    </dict>' >> ExportOptions.plist
              echo "üìã Using development profile as fallback: ${{ env.PROFILE_UUID }}"
            fi
          fi
          echo '</dict>' >> ExportOptions.plist
          echo '</plist>' >> ExportOptions.plist

          echo "üìã Created ExportOptions.plist:"
          cat ExportOptions.plist

          # Create output directory
          mkdir -p ios-export

          # Quick check: Are provisioning profiles still available at export time?
          echo "üîç Pre-export check: Profile availability..."
          PROFILE_COUNT=$(ls ~/Library/MobileDevice/Provisioning\ Profiles/ 2>/dev/null | wc -l || echo 0)
          IDENTITY_COUNT=$(security find-identity -v -p codesigning 2>/dev/null | wc -l || echo 0)
          echo "üìã Found $PROFILE_COUNT profiles and $IDENTITY_COUNT identities"

          # Quick check for distribution profiles with Associated Domains
          DIST_WITH_DOMAINS=0
          ADHOC_WITH_DOMAINS=0
          for profile in ~/Library/MobileDevice/Provisioning\ Profiles/*.mobileprovision; do
            if [ -f "$profile" ]; then
              # Check if it has Associated Domains capability
              HAS_DOMAINS=$(security cms -D -i "$profile" 2>/dev/null | grep -c "com.apple.developer.associated-domains" || echo 0)

              if [ "$HAS_DOMAINS" -gt 0 ]; then
                # Check if it's ad hoc (has ProvisionedDevices but no get-task-allow)
                if security cms -D -i "$profile" 2>/dev/null | grep -q "<key>ProvisionedDevices</key>"; then
                  if security cms -D -i "$profile" 2>/dev/null | grep -q "<false/>"; then
                    ADHOC_WITH_DOMAINS=$((ADHOC_WITH_DOMAINS + 1))
                  fi
                else
                  # No ProvisionedDevices = distribution profile
                  DIST_WITH_DOMAINS=$((DIST_WITH_DOMAINS + 1))
                fi
              fi
            fi
          done
          echo "üìã Distribution profiles with Associated Domains: $DIST_WITH_DOMAINS"
          echo "üìã Ad Hoc profiles with Associated Domains: $ADHOC_WITH_DOMAINS"          # Try to export IPA
          echo "üöÄ Attempting to export IPA..."
          if xcodebuild -exportArchive \
            -archivePath "$XCARCHIVE" \
            -exportPath ./ios-export \
            -exportOptionsPlist ExportOptions.plist \
            -allowProvisioningUpdates 2>&1 | tee ipa_export.log; then

            # Check if IPA was actually created (xcodebuild can exit 0 but still fail)
            if find ./ios-export -name "*.ipa" -type f 2>/dev/null | grep -q ".ipa"; then
              echo "‚úÖ IPA export succeeded"
              find ./ios-export -name "*.ipa" -type f 2>/dev/null
              ls -la ./ios-export/
            else
              echo "‚ùå IPA export completed but no IPA was generated"
              echo "üìã Export directory contents:"
              ls -la ./ios-export/ || echo "Export directory is empty"
              echo "üìã Export log (last 30 lines):"
              tail -30 ipa_export.log || echo "No export log found"
            fi
          else
            echo "‚ùå IPA export failed, but we have the .app bundle"
            echo "üìã Export log:"
            tail -20 ipa_export.log || echo "No export log found"

            # Check what's in the archive
            echo "üìã Archive contents:"
            find "$XCARCHIVE" -type f | head -10 || echo "Cannot list archive contents"
          fi
        else
          echo "‚ùå No xcarchive found for IPA export"
          echo "üìã Looking for any archives:"
          find . -name "*archive*" -type d 2>/dev/null | head -5 || echo "No archives found"
        fi
      env:
        VITE_API_URL: ${{ secrets.VITE_API_URL }}
        VITE_MAPBOX_ACCESS_TOKEN: ${{ secrets.VITE_MAPBOX_ACCESS_TOKEN }}
        APPLE_DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
        CODE_SIGN_IDENTITY: "iPhone Developer"
        CODE_SIGN_STYLE: "Manual"
        DEVELOPMENT_TEAM: ${{ secrets.APPLE_DEVELOPMENT_TEAM }}
        PRODUCT_BUNDLE_IDENTIFIER: "com.beout.app"
        PROVISIONING_PROFILE: ${{ env.PROFILE_UUID }}
        PROVISIONING_PROFILE_SPECIFIER: ${{ env.PROFILE_NAME }}

    - name: Find and Upload IPA
      working-directory: ./client
      if: always()
      run: |
        echo "=== iOS Build Artifacts Search ==="

        echo "=== Searching for IPA files ==="
        find . -name "*.ipa" -type f 2>/dev/null || echo "No IPA files found"

        echo "=== Searching for app bundles ==="
        find . -name "*.app" -type d 2>/dev/null | head -5 || echo "No .app bundles found"

        echo "=== Checking Xcode build directories ==="
        find . -path "*/Build/Products/*" -type f 2>/dev/null | head -10 || echo "No Xcode build products found"

        echo "=== Checking for xcarchive ==="
        find . -name "*.xcarchive" -type d 2>/dev/null || echo "No xcarchive found"

        # Check if we have a successful app bundle
        APP_BUNDLE=$(find . -name "BeOut.app" -type d 2>/dev/null | head -1)
        if [ -n "$APP_BUNDLE" ]; then
          echo "‚úÖ iOS App Bundle found: $APP_BUNDLE"
          echo "üì± App bundle contents:"
          ls -la "$APP_BUNDLE" | head -10

          # Check if it's signed
          if [ -f "$APP_BUNDLE/Info.plist" ]; then
            echo "‚úÖ App bundle appears complete (has Info.plist)"

            # Show bundle info
            echo "üìã Bundle identifier:"
            /usr/libexec/PlistBuddy -c "Print CFBundleIdentifier" "$APP_BUNDLE/Info.plist" 2>/dev/null || echo "Could not read bundle ID"

            echo "üìã Bundle version:"
            /usr/libexec/PlistBuddy -c "Print CFBundleShortVersionString" "$APP_BUNDLE/Info.plist" 2>/dev/null || echo "Could not read version"
          fi

          # Check if it's properly signed
          echo "üìã Code signing status:"
          codesign -dv "$APP_BUNDLE" 2>&1 | head -5 || echo "Could not check code signing"
        else
          echo "‚ùå No iOS app bundle found"
        fi

    - name: Upload IPA (if found)
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: ios-build-artifacts
        path: |
          client/src-tauri/gen/apple/build/app_iOS.xcarchive/Products/Applications/BeOut.app
          client/ios-export/**/*.ipa
          client/src-tauri/gen/apple/build/**/*.ipa
          client/src-tauri/gen/apple/**/*.xcarchive
          client/src-tauri/gen/apple/**/*.app
          client/**/*.ipa
        if-no-files-found: warn

    - name: Cleanup Keychain
      if: always()
      run: |
        echo "üßπ Cleaning up keychain..."
        if [ -n "$KEYCHAIN_PASSWORD" ]; then
          security delete-keychain build.keychain || echo "Keychain already deleted or not found"
        fi
        echo "‚úÖ Cleanup completed"
      env:
        KEYCHAIN_PASSWORD: ${{ env.KEYCHAIN_PASSWORD }}

  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-android, build-ios]  # Now depends on both builds
    if: startsWith(github.ref, 'refs/tags/v')
    steps:
    - uses: actions/checkout@v4

    - name: Download Android APK
      uses: actions/download-artifact@v4
      with:
        name: android-apk
        path: ./artifacts/
      continue-on-error: true

    - name: Download iOS IPA
      uses: actions/download-artifact@v4
      with:
        name: ios-ipa
        path: ./artifacts/
      continue-on-error: true

    - name: List artifacts
      run: |
        echo "Available artifacts:"
        find ./artifacts -type f -name "*.apk" -o -name "*.ipa" 2>/dev/null || echo "No APK or IPA files found"
        ls -la ./artifacts/ 2>/dev/null || echo "No artifacts directory"

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          ./artifacts/*.apk
          ./artifacts/*.ipa
        draft: true
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
